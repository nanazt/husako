use std::collections::BTreeMap;
use std::path::Path;

use serde::{Deserialize, Serialize};

use crate::ConfigError;

pub const LOCK_FILENAME: &str = "husako.lock";

const LOCK_HEADER: &str = "# This file is generated by husako. Commit it to version control.\n# Do not edit it manually.\n\n";

/// Project-root lock file that enables incremental type generation.
///
/// Committed to VCS like `Cargo.lock`. Records what was last generated
/// and from which source identity, so unchanged entries can be skipped.
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub struct HusakoLock {
    pub format_version: u32,
    pub husako_version: String,
    #[serde(default, skip_serializing_if = "BTreeMap::is_empty")]
    pub resources: BTreeMap<String, ResourceLockEntry>,
    #[serde(default, skip_serializing_if = "BTreeMap::is_empty")]
    pub charts: BTreeMap<String, ChartLockEntry>,
    #[serde(default, skip_serializing_if = "BTreeMap::is_empty")]
    pub plugins: BTreeMap<String, PluginLockEntry>,
}

/// Lock entry for a k8s resource schema source.
///
/// k8s resources are regenerated all-or-nothing; individual entries cannot
/// be skipped in isolation (because `resolve_all()` merges them before codegen).
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
#[serde(tag = "source")]
pub enum ResourceLockEntry {
    #[serde(rename = "release")]
    Release {
        version: String,
        generated_at: String,
    },
    #[serde(rename = "git")]
    Git {
        repo: String,
        tag: String,
        path: String,
        generated_at: String,
    },
    #[serde(rename = "file")]
    File {
        path: String,
        content_hash: String,
        generated_at: String,
    },
}

/// Lock entry for a Helm chart values schema source.
///
/// Each chart is independent â€” one chart changing does not force regeneration
/// of other charts.
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
#[serde(tag = "source")]
pub enum ChartLockEntry {
    #[serde(rename = "registry")]
    Registry {
        repo: String,
        chart: String,
        version: String,
        generated_at: String,
    },
    #[serde(rename = "artifacthub")]
    ArtifactHub {
        package: String,
        version: String,
        generated_at: String,
    },
    #[serde(rename = "file")]
    File {
        path: String,
        content_hash: String,
        generated_at: String,
    },
    #[serde(rename = "git")]
    Git {
        repo: String,
        tag: String,
        path: String,
        generated_at: String,
    },
    #[serde(rename = "oci")]
    Oci {
        reference: String,
        version: String,
        generated_at: String,
    },
}

/// Lock entry for an installed plugin.
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
#[serde(tag = "source")]
pub enum PluginLockEntry {
    #[serde(rename = "git")]
    Git {
        url: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        path: Option<String>,
        plugin_version: String,
        generated_at: String,
    },
    #[serde(rename = "path")]
    Path {
        path: String,
        content_hash: String,
        plugin_version: String,
        generated_at: String,
    },
}

/// Load `husako.lock` from the project root.
///
/// Returns `Ok(None)` if the file does not exist.
/// Returns `Err` if the file exists but cannot be parsed.
pub fn load_lock(project_root: &Path) -> Result<Option<HusakoLock>, ConfigError> {
    let path = project_root.join(LOCK_FILENAME);
    if !path.exists() {
        return Ok(None);
    }
    let content = std::fs::read_to_string(&path).map_err(|e| ConfigError::Io {
        path: path.display().to_string(),
        source: e,
    })?;
    let lock: HusakoLock =
        toml::from_str(&content).map_err(|e| ConfigError::Parse(e.to_string()))?;
    Ok(Some(lock))
}

/// Write `husako.lock` to the project root.
pub fn save_lock(project_root: &Path, lock: &HusakoLock) -> Result<(), ConfigError> {
    let path = project_root.join(LOCK_FILENAME);
    let body = toml::to_string_pretty(lock).map_err(|e| ConfigError::Parse(e.to_string()))?;
    let content = format!("{LOCK_HEADER}{body}");
    std::fs::write(&path, content).map_err(|e| ConfigError::Io {
        path: path.display().to_string(),
        source: e,
    })?;
    Ok(())
}

#[cfg(test)]
mod tests {
    use super::*;

    fn make_full_lock() -> HusakoLock {
        let mut resources = BTreeMap::new();
        resources.insert(
            "kubernetes".to_string(),
            ResourceLockEntry::Release {
                version: "1.35".to_string(),
                generated_at: "2026-02-26T14:03:00Z".to_string(),
            },
        );
        resources.insert(
            "cert-manager".to_string(),
            ResourceLockEntry::Git {
                repo: "https://github.com/cert-manager/cert-manager".to_string(),
                tag: "v1.17.2".to_string(),
                path: "deploy/crds".to_string(),
                generated_at: "2026-02-26T14:03:05Z".to_string(),
            },
        );
        resources.insert(
            "my-crd".to_string(),
            ResourceLockEntry::File {
                path: "./crds/my-crd.yaml".to_string(),
                content_hash: "a1b2c3d4e5f67890".to_string(),
                generated_at: "2026-02-26T14:03:05Z".to_string(),
            },
        );

        let mut charts = BTreeMap::new();
        charts.insert(
            "ingress-nginx".to_string(),
            ChartLockEntry::Registry {
                repo: "https://kubernetes.github.io/ingress-nginx".to_string(),
                chart: "ingress-nginx".to_string(),
                version: "4.12.0".to_string(),
                generated_at: "2026-02-26T14:03:10Z".to_string(),
            },
        );
        charts.insert(
            "postgresql".to_string(),
            ChartLockEntry::ArtifactHub {
                package: "bitnami/postgresql".to_string(),
                version: "16.4.0".to_string(),
                generated_at: "2026-02-26T14:03:12Z".to_string(),
            },
        );
        charts.insert(
            "my-values".to_string(),
            ChartLockEntry::File {
                path: "./schemas/my-chart.schema.json".to_string(),
                content_hash: "f0e1d2c3b4a59687".to_string(),
                generated_at: "2026-02-26T14:03:05Z".to_string(),
            },
        );
        charts.insert(
            "my-git-chart".to_string(),
            ChartLockEntry::Git {
                repo: "https://github.com/example/charts".to_string(),
                tag: "v1.0.0".to_string(),
                path: "charts/my-chart".to_string(),
                generated_at: "2026-02-26T14:03:08Z".to_string(),
            },
        );
        charts.insert(
            "postgresql-oci".to_string(),
            ChartLockEntry::Oci {
                reference: "oci://ghcr.io/org/postgresql".to_string(),
                version: "1.2.3".to_string(),
                generated_at: "2026-02-26T14:03:14Z".to_string(),
            },
        );

        let mut plugins = BTreeMap::new();
        plugins.insert(
            "fluxcd".to_string(),
            PluginLockEntry::Git {
                url: "https://github.com/nanazt/husako".to_string(),
                path: Some("plugins/fluxcd".to_string()),
                plugin_version: "0.2.0".to_string(),
                generated_at: "2026-02-26T14:03:02Z".to_string(),
            },
        );
        plugins.insert(
            "my-local-plugin".to_string(),
            PluginLockEntry::Path {
                path: "./plugins/my-plugin".to_string(),
                content_hash: "1234567890abcdef".to_string(),
                plugin_version: "0.1.0".to_string(),
                generated_at: "2026-02-26T14:03:02Z".to_string(),
            },
        );

        HusakoLock {
            format_version: 1,
            husako_version: "0.3.0".to_string(),
            resources,
            charts,
            plugins,
        }
    }

    #[test]
    fn roundtrip() {
        let lock = make_full_lock();
        let toml_str = toml::to_string_pretty(&lock).expect("serialize failed");
        let deserialized: HusakoLock = toml::from_str(&toml_str).expect("deserialize failed");
        assert_eq!(lock, deserialized);
    }

    #[test]
    fn load_missing_returns_none() {
        let tmp = tempfile::tempdir().unwrap();
        let result = load_lock(tmp.path()).unwrap();
        assert!(result.is_none());
    }

    #[test]
    fn load_malformed_returns_error() {
        let tmp = tempfile::tempdir().unwrap();
        std::fs::write(tmp.path().join(LOCK_FILENAME), "invalid [[ toml").unwrap();
        let err = load_lock(tmp.path()).unwrap_err();
        assert!(matches!(err, ConfigError::Parse(_)));
    }

    #[test]
    fn load_unknown_source_tag_returns_error() {
        let tmp = tempfile::tempdir().unwrap();
        std::fs::write(
            tmp.path().join(LOCK_FILENAME),
            "format_version = 1\nhusako_version = \"0.1.0\"\n\n[resources.foo]\nsource = \"unknown\"\n",
        )
        .unwrap();
        let err = load_lock(tmp.path()).unwrap_err();
        assert!(matches!(err, ConfigError::Parse(_)));
    }

    #[test]
    fn save_and_load_roundtrip() {
        let tmp = tempfile::tempdir().unwrap();
        let lock = make_full_lock();
        save_lock(tmp.path(), &lock).unwrap();

        // Verify header comment is present
        let content = std::fs::read_to_string(tmp.path().join(LOCK_FILENAME)).unwrap();
        assert!(content.starts_with("# This file is generated by husako."));

        // Verify roundtrip
        let loaded = load_lock(tmp.path()).unwrap().unwrap();
        assert_eq!(lock, loaded);
    }

    #[test]
    fn empty_lock_serializes_without_empty_sections() {
        let lock = HusakoLock {
            format_version: 1,
            husako_version: "0.1.0".to_string(),
            resources: BTreeMap::new(),
            charts: BTreeMap::new(),
            plugins: BTreeMap::new(),
        };
        let toml_str = toml::to_string_pretty(&lock).unwrap();
        assert!(!toml_str.contains("[resources]"));
        assert!(!toml_str.contains("[charts]"));
        assert!(!toml_str.contains("[plugins]"));
    }

    #[test]
    fn plugin_git_without_path_serializes_cleanly() {
        let mut plugins = BTreeMap::new();
        plugins.insert(
            "test".to_string(),
            PluginLockEntry::Git {
                url: "https://github.com/example/plugin".to_string(),
                path: None,
                plugin_version: "1.0.0".to_string(),
                generated_at: "2026-02-26T14:00:00Z".to_string(),
            },
        );
        let lock = HusakoLock {
            format_version: 1,
            husako_version: "0.1.0".to_string(),
            resources: BTreeMap::new(),
            charts: BTreeMap::new(),
            plugins,
        };
        let toml_str = toml::to_string_pretty(&lock).unwrap();
        assert!(!toml_str.contains("path ="));
        let back: HusakoLock = toml::from_str(&toml_str).unwrap();
        assert_eq!(lock, back);
    }
}
