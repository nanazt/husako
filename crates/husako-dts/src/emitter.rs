use std::collections::HashSet;
use std::fmt::Write;

use crate::schema::{PropertyInfo, SchemaInfo, TsType};

/// Format a TsType into its TypeScript string representation.
pub fn format_ts_type(ty: &TsType) -> String {
    match ty {
        TsType::String => "string".to_string(),
        TsType::Number => "number".to_string(),
        TsType::Boolean => "boolean".to_string(),
        TsType::IntOrString => "number | string".to_string(),
        TsType::Array(inner) => format!("{}[]", format_ts_type(inner)),
        TsType::Map(val) => format!("Record<string, {}>", format_ts_type(val)),
        TsType::Ref(name) => name.clone(),
        TsType::Any => "any".to_string(),
    }
}

/// Emit a single TypeScript interface.
pub fn emit_interface(schema: &SchemaInfo) -> String {
    let mut out = String::new();

    if let Some(desc) = &schema.description {
        let _ = writeln!(out, "/** {desc} */");
    }
    let _ = writeln!(out, "export interface {} {{", schema.ts_name);

    for prop in &schema.properties {
        emit_property(&mut out, prop);
    }

    let _ = writeln!(out, "}}");
    out
}

fn emit_property(out: &mut String, prop: &PropertyInfo) {
    if let Some(desc) = &prop.description {
        let _ = writeln!(out, "  /** {desc} */");
    }
    let opt = if prop.required { "" } else { "?" };
    let _ = writeln!(
        out,
        "  {}{}: {};",
        prop.name,
        opt,
        format_ts_type(&prop.ts_type)
    );
}

/// Emit a builder class for a registered kind.
pub fn emit_builder_class(schema: &SchemaInfo, api_version: &str) -> String {
    let mut out = String::new();

    if let Some(desc) = &schema.description {
        let _ = writeln!(out, "/** {desc} */");
    }
    let _ = writeln!(
        out,
        "export class {} extends _ResourceBuilder {{",
        schema.ts_name
    );
    let _ = writeln!(out, "  constructor();");
    let _ = writeln!(out, "}}");

    // Suppress unused warning — api_version is available for future use
    let _ = api_version;

    out
}

/// Collect all `Ref` type names used by a set of schemas.
fn collect_refs(schemas: &[&SchemaInfo]) -> HashSet<String> {
    let mut refs = HashSet::new();
    for schema in schemas {
        for prop in &schema.properties {
            collect_type_refs(&prop.ts_type, &mut refs);
        }
    }
    refs
}

fn collect_type_refs(ty: &TsType, refs: &mut HashSet<String>) {
    match ty {
        TsType::Ref(name) => {
            refs.insert(name.clone());
        }
        TsType::Array(inner) | TsType::Map(inner) => collect_type_refs(inner, refs),
        _ => {}
    }
}

/// Emit `_common.d.ts` from common schemas.
pub fn emit_common(schemas: &[&SchemaInfo]) -> String {
    let mut out = String::new();

    let _ = writeln!(out, "// Auto-generated by husako. Do not edit.\n");

    // Collect refs to determine which types from _common itself are referenced
    let refs = collect_refs(schemas);
    let local_names: HashSet<&str> = schemas.iter().map(|s| s.ts_name.as_str()).collect();

    // Find refs to types that aren't in common — these would be from other modules.
    // For common, we don't import anything external.
    let external_refs: Vec<&String> = refs
        .iter()
        .filter(|r| !local_names.contains(r.as_str()))
        .collect();
    if !external_refs.is_empty() {
        // These are unknown refs; emit them as `any` type alias.
        for r in &external_refs {
            let _ = writeln!(out, "type {r} = any;");
        }
        let _ = writeln!(out);
    }

    for schema in schemas {
        let _ = write!(out, "{}", emit_interface(schema));
        let _ = writeln!(out);
    }

    out
}

/// Emit a per-group-version `.d.ts` file.
///
/// `schemas` — all schemas belonging to this group-version.
/// `registered_kinds` — set of kind names that have runtime builders.
/// `common_names` — set of type names available in `_common.d.ts`.
pub fn emit_group_version(
    schemas: &[&SchemaInfo],
    registered_kinds: &HashSet<String>,
    common_names: &HashSet<String>,
) -> String {
    let mut out = String::new();

    let _ = writeln!(out, "// Auto-generated by husako. Do not edit.\n");

    let has_builders = schemas
        .iter()
        .any(|s| s.gvk.is_some() && registered_kinds.contains(&s.ts_name));

    // Collect all referenced types
    let refs = collect_refs(schemas);
    let local_names: HashSet<&str> = schemas.iter().map(|s| s.ts_name.as_str()).collect();

    // Import _ResourceBuilder if there are builders
    if has_builders {
        let _ = writeln!(
            out,
            "import {{ _ResourceBuilder }} from \"husako/_base\";\n"
        );
    }

    // Import common types that are referenced but not defined locally
    let common_imports: Vec<&String> = refs
        .iter()
        .filter(|r| !local_names.contains(r.as_str()) && common_names.contains(r.as_str()))
        .collect();

    if !common_imports.is_empty() {
        let mut sorted: Vec<&&String> = common_imports.iter().collect();
        sorted.sort();
        let names: Vec<&str> = sorted.iter().map(|s| s.as_str()).collect();
        let _ = writeln!(
            out,
            "import {{ {} }} from \"k8s/_common\";\n",
            names.join(", ")
        );
    }

    // Emit interfaces
    for schema in schemas {
        let _ = write!(out, "{}", emit_interface(schema));
        let _ = writeln!(out);
    }

    // Emit builder classes for registered kinds
    for schema in schemas {
        if let Some(gvk) = &schema.gvk
            && registered_kinds.contains(&schema.ts_name)
        {
            let api_version = if gvk.group.is_empty() {
                gvk.version.clone()
            } else {
                format!("{}/{}", gvk.group, gvk.version)
            };
            let _ = write!(out, "{}", emit_builder_class(schema, &api_version));
            let _ = writeln!(out);
        }
    }

    out
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::schema::{GroupVersionKind, SchemaLocation};

    fn make_schema(name: &str, props: Vec<PropertyInfo>) -> SchemaInfo {
        SchemaInfo {
            full_name: format!("io.k8s.api.apps.v1.{name}"),
            ts_name: name.to_string(),
            location: SchemaLocation::GroupVersion {
                group: "apps".to_string(),
                version: "v1".to_string(),
            },
            properties: props,
            gvk: None,
            description: None,
        }
    }

    #[test]
    fn format_basic_types() {
        assert_eq!(format_ts_type(&TsType::String), "string");
        assert_eq!(format_ts_type(&TsType::Number), "number");
        assert_eq!(format_ts_type(&TsType::Boolean), "boolean");
        assert_eq!(format_ts_type(&TsType::IntOrString), "number | string");
        assert_eq!(format_ts_type(&TsType::Any), "any");
    }

    #[test]
    fn format_composite_types() {
        assert_eq!(
            format_ts_type(&TsType::Array(Box::new(TsType::String))),
            "string[]"
        );
        assert_eq!(
            format_ts_type(&TsType::Map(Box::new(TsType::Number))),
            "Record<string, number>"
        );
        assert_eq!(
            format_ts_type(&TsType::Ref("ObjectMeta".to_string())),
            "ObjectMeta"
        );
    }

    #[test]
    fn emit_interface_snapshot() {
        let schema = make_schema(
            "DeploymentSpec",
            vec![
                PropertyInfo {
                    name: "replicas".to_string(),
                    ts_type: TsType::Number,
                    required: false,
                    description: Some("Number of desired pods.".to_string()),
                },
                PropertyInfo {
                    name: "selector".to_string(),
                    ts_type: TsType::Ref("LabelSelector".to_string()),
                    required: true,
                    description: None,
                },
            ],
        );

        let output = emit_interface(&schema);
        insta::assert_snapshot!(output);
    }

    #[test]
    fn emit_builder_class_snapshot() {
        let mut schema = make_schema("Deployment", vec![]);
        schema.gvk = Some(GroupVersionKind {
            group: "apps".to_string(),
            version: "v1".to_string(),
            kind: "Deployment".to_string(),
        });
        schema.description =
            Some("Deployment enables declarative updates for Pods and ReplicaSets.".to_string());

        let output = emit_builder_class(&schema, "apps/v1");
        insta::assert_snapshot!(output);
    }

    #[test]
    fn emit_common_snapshot() {
        let s1 = SchemaInfo {
            full_name: "io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta".to_string(),
            ts_name: "ObjectMeta".to_string(),
            location: SchemaLocation::Common,
            properties: vec![
                PropertyInfo {
                    name: "name".to_string(),
                    ts_type: TsType::String,
                    required: false,
                    description: None,
                },
                PropertyInfo {
                    name: "namespace".to_string(),
                    ts_type: TsType::String,
                    required: false,
                    description: None,
                },
                PropertyInfo {
                    name: "labels".to_string(),
                    ts_type: TsType::Map(Box::new(TsType::String)),
                    required: false,
                    description: None,
                },
            ],
            gvk: None,
            description: Some(
                "ObjectMeta is metadata attached to every Kubernetes object.".to_string(),
            ),
        };

        let s2 = SchemaInfo {
            full_name: "io.k8s.apimachinery.pkg.apis.meta.v1.LabelSelector".to_string(),
            ts_name: "LabelSelector".to_string(),
            location: SchemaLocation::Common,
            properties: vec![PropertyInfo {
                name: "matchLabels".to_string(),
                ts_type: TsType::Map(Box::new(TsType::String)),
                required: false,
                description: None,
            }],
            gvk: None,
            description: None,
        };

        let schemas: Vec<&SchemaInfo> = vec![&s1, &s2];
        let output = emit_common(&schemas);
        insta::assert_snapshot!(output);
    }

    #[test]
    fn emit_group_version_snapshot() {
        let deployment = SchemaInfo {
            full_name: "io.k8s.api.apps.v1.Deployment".to_string(),
            ts_name: "Deployment".to_string(),
            location: SchemaLocation::GroupVersion {
                group: "apps".to_string(),
                version: "v1".to_string(),
            },
            properties: vec![
                PropertyInfo {
                    name: "metadata".to_string(),
                    ts_type: TsType::Ref("ObjectMeta".to_string()),
                    required: false,
                    description: None,
                },
                PropertyInfo {
                    name: "spec".to_string(),
                    ts_type: TsType::Ref("DeploymentSpec".to_string()),
                    required: false,
                    description: None,
                },
            ],
            gvk: Some(GroupVersionKind {
                group: "apps".to_string(),
                version: "v1".to_string(),
                kind: "Deployment".to_string(),
            }),
            description: None,
        };

        let spec = SchemaInfo {
            full_name: "io.k8s.api.apps.v1.DeploymentSpec".to_string(),
            ts_name: "DeploymentSpec".to_string(),
            location: SchemaLocation::GroupVersion {
                group: "apps".to_string(),
                version: "v1".to_string(),
            },
            properties: vec![PropertyInfo {
                name: "replicas".to_string(),
                ts_type: TsType::Number,
                required: false,
                description: None,
            }],
            gvk: None,
            description: None,
        };

        let schemas: Vec<&SchemaInfo> = vec![&deployment, &spec];
        let registered = HashSet::from(["Deployment".to_string()]);
        let common = HashSet::from(["ObjectMeta".to_string()]);

        let output = emit_group_version(&schemas, &registered, &common);
        insta::assert_snapshot!(output);
    }
}
