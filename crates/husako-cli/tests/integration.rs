use std::io::Write;
use std::path::Path;

use assert_cmd::cargo::cargo_bin_cmd;
use tempfile::NamedTempFile;

fn husako() -> assert_cmd::Command {
    cargo_bin_cmd!("husako")
}

fn husako_at(dir: &std::path::Path) -> assert_cmd::Command {
    let mut cmd = cargo_bin_cmd!("husako");
    cmd.current_dir(dir);
    cmd
}

fn write_temp_ts(content: &str) -> NamedTempFile {
    let mut f = tempfile::Builder::new().suffix(".ts").tempfile().unwrap();
    f.write_all(content.as_bytes()).unwrap();
    f
}

/// Write generated k8s runtime JS modules into `.husako/types/k8s/` under `root`.
fn write_k8s_modules(root: &Path) {
    let apps_dir = root.join(".husako/types/k8s/apps");
    std::fs::create_dir_all(&apps_dir).unwrap();
    std::fs::write(
        apps_dir.join("v1.js"),
        r#"// Auto-generated by husako. Do not edit.

import { _ResourceBuilder } from "husako/_base";

class _Deployment extends _ResourceBuilder {
  constructor() { super("apps/v1", "Deployment"); }
  replicas(v) { return this._setSpec("replicas", v); }
  selector(v) { return this._setSpec("selector", v); }
  strategy(v) { return this._setSpec("strategy", v); }
  template(v) { return this._setSpec("template", v); }
  containers(v) { return this._setDeep("template.spec.containers", v); }
  initContainers(v) { return this._setDeep("template.spec.initContainers", v); }
}
export function Deployment() { return new _Deployment(); }

class _StatefulSet extends _ResourceBuilder {
  constructor() { super("apps/v1", "StatefulSet"); }
  replicas(v) { return this._setSpec("replicas", v); }
  selector(v) { return this._setSpec("selector", v); }
  template(v) { return this._setSpec("template", v); }
  containers(v) { return this._setDeep("template.spec.containers", v); }
  initContainers(v) { return this._setDeep("template.spec.initContainers", v); }
}
export function StatefulSet() { return new _StatefulSet(); }

class _DaemonSet extends _ResourceBuilder {
  constructor() { super("apps/v1", "DaemonSet"); }
  selector(v) { return this._setSpec("selector", v); }
  template(v) { return this._setSpec("template", v); }
  containers(v) { return this._setDeep("template.spec.containers", v); }
  initContainers(v) { return this._setDeep("template.spec.initContainers", v); }
}
export function DaemonSet() { return new _DaemonSet(); }
"#,
    )
    .unwrap();

    let core_dir = root.join(".husako/types/k8s/core");
    std::fs::create_dir_all(&core_dir).unwrap();
    std::fs::write(
        core_dir.join("v1.js"),
        r#"// Auto-generated by husako. Do not edit.

import { _ResourceBuilder, _SchemaBuilder } from "husako/_base";

class _Namespace extends _ResourceBuilder {
  constructor() { super("v1", "Namespace"); }
}
export function Namespace() { return new _Namespace(); }

class _Service extends _ResourceBuilder {
  constructor() { super("v1", "Service"); }
  selector(v) { return this._setSpec("selector", v); }
  ports(v) { return this._setSpec("ports", v); }
  type(v) { return this._setSpec("type", v); }
}
export function Service() { return new _Service(); }

class _ConfigMap extends _ResourceBuilder {
  constructor() { super("v1", "ConfigMap"); }
  data(v) { return this.set("data", v); }
  binaryData(v) { return this.set("binaryData", v); }
  immutable(v) { return this.set("immutable", v); }
}
export function ConfigMap() { return new _ConfigMap(); }

class _Container extends _SchemaBuilder {
  name(v) { return this._set("name", v); }
  image(v) { return this._set("image", v); }
  ports(v) { return this._set("ports", v); }
  resources(v) { return this._set("resources", v); }
  env(v) { return this._set("env", v); }
  command(v) { return this._set("command", v); }
  args(v) { return this._set("args", v); }
  volumeMounts(v) { return this._set("volumeMounts", v); }
}
export function Container() { return new _Container(); }

class _PodTemplateSpec extends _SchemaBuilder {
  metadata(v) { return this._set("metadata", v); }
  spec(v) { return this._set("spec", v); }
}
export function PodTemplateSpec() { return new _PodTemplateSpec(); }
export function PodTemplate() { return new _PodTemplateSpec(); }
"#,
    )
    .unwrap();

    // _common.js for common schema builders (LabelSelector, etc.)
    let common_dir = root.join(".husako/types/k8s");
    std::fs::write(
        common_dir.join("_common.js"),
        r#"// Auto-generated by husako. Do not edit.

import { _SchemaBuilder } from "husako/_base";

class _LabelSelector extends _SchemaBuilder {
  matchLabels(v) { return this._set("matchLabels", v); }
  matchExpressions(v) { return this._set("matchExpressions", v); }
}
export function LabelSelector() { return new _LabelSelector(); }
"#,
    )
    .unwrap();
}

/// Create a temp project dir with k8s modules, write the given TS content as entry.ts,
/// and return (tempdir, entry_path).
fn project_with_k8s(ts_content: &str) -> (tempfile::TempDir, std::path::PathBuf) {
    let dir = tempfile::tempdir().unwrap();
    let root = dir.path();
    write_k8s_modules(root);

    let entry = root.join("entry.ts");
    std::fs::write(&entry, ts_content).unwrap();
    (dir, entry)
}

#[test]
fn missing_build() {
    let f = write_temp_ts(r#"import { build } from "husako"; const x = 1;"#);
    husako()
        .args(["render", f.path().to_str().unwrap()])
        .assert()
        .code(7)
        .stderr(predicates::str::contains("build() was not called"));
}

#[test]
fn double_build() {
    let f = write_temp_ts(r#"import { build } from "husako"; build([]); build([]);"#);
    husako()
        .args(["render", f.path().to_str().unwrap()])
        .assert()
        .code(7)
        .stderr(predicates::str::contains("called 2 times"));
}

#[test]
fn strict_json_undefined() {
    let f = write_temp_ts(
        r#"import { build } from "husako"; build({ _render() { return { a: undefined }; } });"#,
    );
    husako()
        .args(["render", f.path().to_str().unwrap()])
        .assert()
        .code(7)
        .stderr(predicates::str::contains("undefined"));
}

#[test]
fn strict_json_function() {
    let f = write_temp_ts(
        r#"import { build } from "husako"; build({ _render() { return { fn: () => {} }; } });"#,
    );
    husako()
        .args(["render", f.path().to_str().unwrap()])
        .assert()
        .code(7)
        .stderr(predicates::str::contains("function"));
}

#[test]
fn compile_error() {
    let f = write_temp_ts("const = ;");
    husako()
        .args(["render", f.path().to_str().unwrap()])
        .assert()
        .code(3);
}

// --- Milestone 2: Module Loader + Project Imports ---

#[test]
fn render_project_imports() {
    let dir = tempfile::tempdir().unwrap();
    let root = dir.path();
    write_k8s_modules(root);

    // Replicate examples/project/ structure with builders
    std::fs::create_dir_all(root.join("lib")).unwrap();
    std::fs::write(
        root.join("lib/metadata.ts"),
        r#"import { metadata } from "husako";
export function appMetadata(appName: string) {
  return metadata().name(appName).label("app", appName);
}
"#,
    )
    .unwrap();
    std::fs::write(
        root.join("lib/index.ts"),
        r#"export { appMetadata } from "./metadata";"#,
    )
    .unwrap();

    std::fs::create_dir_all(root.join("deployments")).unwrap();
    std::fs::write(
        root.join("deployments/nginx.ts"),
        r#"import { Deployment } from "k8s/apps/v1";
import { Container } from "k8s/core/v1";
import { LabelSelector } from "k8s/_common";
import { appMetadata } from "../lib";
export const nginx = Deployment()
  .metadata(appMetadata("nginx"))
  .replicas(1)
  .selector(LabelSelector().matchLabels({ app: "nginx" }))
  .containers([Container().name("nginx").image("nginx:1.25")]);
"#,
    )
    .unwrap();

    std::fs::create_dir_all(root.join("env")).unwrap();
    let entry = root.join("env/dev.ts");
    std::fs::write(
        &entry,
        r#"import { build } from "husako";
import { nginx } from "../deployments/nginx";
build([nginx]);
"#,
    )
    .unwrap();

    husako_at(root)
        .args(["render", entry.to_str().unwrap()])
        .assert()
        .success()
        .stdout(predicates::str::contains("apiVersion: apps/v1"))
        .stdout(predicates::str::contains("kind: Deployment"))
        .stdout(predicates::str::contains("name: nginx"))
        .stdout(predicates::str::contains("app: nginx"));
}

#[test]
fn render_project_snapshot() {
    let dir = tempfile::tempdir().unwrap();
    let root = dir.path();
    write_k8s_modules(root);

    std::fs::create_dir_all(root.join("lib")).unwrap();
    std::fs::write(
        root.join("lib/metadata.ts"),
        r#"import { metadata } from "husako";
export function appMetadata(appName: string) {
  return metadata().name(appName).label("app", appName);
}
"#,
    )
    .unwrap();
    std::fs::write(
        root.join("lib/index.ts"),
        r#"export { appMetadata } from "./metadata";"#,
    )
    .unwrap();

    std::fs::create_dir_all(root.join("deployments")).unwrap();
    std::fs::write(
        root.join("deployments/nginx.ts"),
        r#"import { Deployment } from "k8s/apps/v1";
import { Container } from "k8s/core/v1";
import { LabelSelector } from "k8s/_common";
import { appMetadata } from "../lib";
export const nginx = Deployment()
  .metadata(appMetadata("nginx"))
  .replicas(1)
  .selector(LabelSelector().matchLabels({ app: "nginx" }))
  .containers([Container().name("nginx").image("nginx:1.25")]);
"#,
    )
    .unwrap();

    std::fs::create_dir_all(root.join("env")).unwrap();
    let entry = root.join("env/dev.ts");
    std::fs::write(
        &entry,
        r#"import { build } from "husako";
import { nginx } from "../deployments/nginx";
build([nginx]);
"#,
    )
    .unwrap();

    let output = husako_at(root)
        .args(["render", entry.to_str().unwrap()])
        .output()
        .unwrap();
    assert!(output.status.success());
    let yaml = String::from_utf8(output.stdout).unwrap();
    insta::assert_snapshot!(yaml);
}

#[test]
fn reject_outside_root() {
    let dir = tempfile::tempdir().unwrap();
    let root = dir.path();
    let sub = root.join("sub");
    std::fs::create_dir(&sub).unwrap();

    // Create a file outside the sub directory
    std::fs::write(root.join("secret.ts"), "export const x = 1;").unwrap();

    // Create entry file that imports outside root
    let entry = sub.join("entry.ts");
    std::fs::write(
        &entry,
        r#"import { build } from "husako"; import { x } from "../secret"; build([{ _render() { return { v: x }; } }]);"#,
    )
    .unwrap();

    // Run with cwd=sub so project_root=sub
    husako_at(&sub)
        .args(["render", entry.to_str().unwrap()])
        .assert()
        .code(4)
        .stderr(predicates::str::contains("outside project root"));
}

#[test]
fn allow_outside_root_flag() {
    let dir = tempfile::tempdir().unwrap();
    let root = dir.path();
    let sub = root.join("sub");
    std::fs::create_dir(&sub).unwrap();

    std::fs::write(root.join("outside.ts"), "export const val = 42;").unwrap();

    let entry = sub.join("entry.ts");
    std::fs::write(
        &entry,
        r#"import { build } from "husako"; import { val } from "../outside"; build([{ _render() { return { v: val }; } }]);"#,
    )
    .unwrap();

    // With --allow-outside-root, the boundary check is bypassed
    husako_at(&sub)
        .args(["render", "--allow-outside-root", entry.to_str().unwrap()])
        .assert()
        .success()
        .stdout(predicates::str::contains("v: 42"));
}

#[test]
fn extension_inference() {
    let dir = tempfile::tempdir().unwrap();
    let root = dir.path();

    // import "./lib" should resolve to lib.ts
    std::fs::write(root.join("lib.ts"), "export const x: number = 1;").unwrap();
    let entry = root.join("entry.ts");
    std::fs::write(
        &entry,
        r#"import { build } from "husako"; import { x } from "./lib"; build([{ _render() { return { v: x }; } }]);"#,
    )
    .unwrap();

    husako_at(root)
        .args(["render", entry.to_str().unwrap()])
        .assert()
        .success()
        .stdout(predicates::str::contains("v: 1"));
}

// --- Milestone 3: SDK Builders (now using generated k8s modules) ---

#[test]
fn render_canonical() {
    let (dir, entry) = project_with_k8s(
        r#"
import * as husako from "husako";
import { Deployment } from "k8s/apps/v1";
import { name, namespace, label, cpu, memory, requests, limits } from "husako";

const nginx_metadata = name("nginx")
  .namespace("nginx-ns")
  .label("key1", "value1")
  .label("key2", "value2");

const another_labels_1 = label("key3", "value3").label("key4", "value4");
const another_labels_2 = label("key5", "value5").label("key6", "value6");

const nginx = Deployment()
  .metadata(husako.merge([nginx_metadata, another_labels_1, another_labels_2]))
  .resources(
    requests(cpu(1).memory("2Gi")).limits(cpu("500m").memory(1))
  );

husako.build([nginx]);
"#,
    );
    husako_at(dir.path())
        .args(["render", entry.to_str().unwrap()])
        .assert()
        .success()
        .stdout(predicates::str::contains("apiVersion: apps/v1"))
        .stdout(predicates::str::contains("kind: Deployment"))
        .stdout(predicates::str::contains("name: nginx"))
        .stdout(predicates::str::contains("namespace: nginx-ns"))
        .stdout(predicates::str::contains("key1: value1"))
        .stdout(predicates::str::contains("key5: value5"))
        .stdout(predicates::str::contains("cpu: '1'"))
        .stdout(predicates::str::contains("memory: 2Gi"))
        .stdout(predicates::str::contains("cpu: 500m"))
        .stdout(predicates::str::contains("memory: 1Gi"));
}

#[test]
fn render_canonical_snapshot() {
    let (dir, entry) = project_with_k8s(
        r#"
import * as husako from "husako";
import { Deployment } from "k8s/apps/v1";
import { name, namespace, label, cpu, memory, requests, limits } from "husako";

const nginx_metadata = name("nginx")
  .namespace("nginx-ns")
  .label("key1", "value1")
  .label("key2", "value2");

const another_labels_1 = label("key3", "value3").label("key4", "value4");
const another_labels_2 = label("key5", "value5").label("key6", "value6");

const nginx = Deployment()
  .metadata(husako.merge([nginx_metadata, another_labels_1, another_labels_2]))
  .resources(
    requests(cpu(1).memory("2Gi")).limits(cpu("500m").memory(1))
  );

husako.build([nginx]);
"#,
    );
    let output = husako_at(dir.path())
        .args(["render", entry.to_str().unwrap()])
        .output()
        .unwrap();
    assert!(output.status.success());
    let yaml = String::from_utf8(output.stdout).unwrap();
    insta::assert_snapshot!(yaml);
}

#[test]
fn metadata_fragment_reuse() {
    let (dir, entry) = project_with_k8s(
        r#"
import { build, label } from "husako";
import { Deployment } from "k8s/apps/v1";
const base = label("env", "dev");
const a = base.label("team", "a");
const b = base.label("team", "b");
const da = Deployment().metadata(a);
const db = Deployment().metadata(b);
build([da, db]);
"#,
    );
    let output = husako_at(dir.path())
        .args(["render", entry.to_str().unwrap()])
        .output()
        .unwrap();
    assert!(output.status.success());
    let yaml = String::from_utf8(output.stdout).unwrap();
    // Both should have env: dev
    assert_eq!(yaml.matches("env: dev").count(), 2);
    // a should have team: a, b should have team: b
    assert!(yaml.contains("team: a"));
    assert!(yaml.contains("team: b"));
}

#[test]
fn merge_labels_deep() {
    let (dir, entry) = project_with_k8s(
        r#"
import { build, name, label, merge } from "husako";
import { Deployment } from "k8s/apps/v1";
const m = merge([name("test"), label("a", "1"), label("b", "2"), label("c", "3")]);
const d = Deployment().metadata(m);
build([d]);
"#,
    );
    husako_at(dir.path())
        .args(["render", entry.to_str().unwrap()])
        .assert()
        .success()
        .stdout(predicates::str::contains("name: test"))
        .stdout(predicates::str::contains("a: '1'"))
        .stdout(predicates::str::contains("b: '2'"))
        .stdout(predicates::str::contains("c: '3'"));
}

#[test]
fn cpu_normalization() {
    let (dir, entry) = project_with_k8s(
        r#"
import { build, cpu, requests } from "husako";
import { Deployment } from "k8s/apps/v1";
const d = Deployment().resources(requests(cpu(0.5)));
build([d]);
"#,
    );
    husako_at(dir.path())
        .args(["render", entry.to_str().unwrap()])
        .assert()
        .success()
        .stdout(predicates::str::contains("cpu: 500m"));
}

#[test]
fn memory_normalization() {
    let (dir, entry) = project_with_k8s(
        r#"
import { build, memory, requests } from "husako";
import { Deployment } from "k8s/apps/v1";
const d = Deployment().resources(requests(memory(4)));
build([d]);
"#,
    );
    husako_at(dir.path())
        .args(["render", entry.to_str().unwrap()])
        .assert()
        .success()
        .stdout(predicates::str::contains("memory: 4Gi"));
}

#[test]
fn k8s_core_v1_namespace() {
    let (dir, entry) = project_with_k8s(
        r#"
import { build, name } from "husako";
import { Namespace } from "k8s/core/v1";
const ns = Namespace().metadata(name("my-ns"));
build([ns]);
"#,
    );
    husako_at(dir.path())
        .args(["render", entry.to_str().unwrap()])
        .assert()
        .success()
        .stdout(predicates::str::contains("apiVersion: v1"))
        .stdout(predicates::str::contains("kind: Namespace"))
        .stdout(predicates::str::contains("name: my-ns"));
}

#[test]
fn index_inference() {
    let dir = tempfile::tempdir().unwrap();
    let root = dir.path();

    // import "./lib" should resolve to lib/index.ts
    let lib = root.join("lib");
    std::fs::create_dir(&lib).unwrap();
    std::fs::write(lib.join("index.ts"), "export const x: number = 99;").unwrap();

    let entry = root.join("entry.ts");
    std::fs::write(
        &entry,
        r#"import { build } from "husako"; import { x } from "./lib"; build([{ _render() { return { v: x }; } }]);"#,
    )
    .unwrap();

    husako_at(root)
        .args(["render", entry.to_str().unwrap()])
        .assert()
        .success()
        .stdout(predicates::str::contains("v: 99"));
}

// --- Milestone 6: Schema-aware Quantity Validation ---

#[test]
fn invalid_quantity_fallback_exit_7() {
    let f = write_temp_ts(
        r#"
import { build } from "husako";
build([{ _render() { return {
    apiVersion: "apps/v1",
    kind: "Deployment",
    spec: {
        template: {
            spec: {
                containers: [{
                    resources: {
                        requests: { cpu: "2gb" }
                    }
                }]
            }
        }
    }
}; } }]);
"#,
    );
    husako()
        .args(["render", f.path().to_str().unwrap()])
        .assert()
        .code(7)
        .stderr(predicates::str::contains("invalid quantity"))
        .stderr(predicates::str::contains("2gb"));
}

#[test]
fn valid_quantities_exit_0() {
    let f = write_temp_ts(
        r#"
import { build } from "husako";
build([{ _render() { return {
    apiVersion: "apps/v1",
    kind: "Deployment",
    spec: {
        template: {
            spec: {
                containers: [{
                    resources: {
                        requests: { cpu: "500m", memory: "1Gi" },
                        limits: { cpu: "1", memory: "2Gi" }
                    }
                }]
            }
        }
    }
}; } }]);
"#,
    );
    husako()
        .args(["render", f.path().to_str().unwrap()])
        .assert()
        .success();
}

#[test]
fn numbers_at_quantity_positions_exit_0() {
    let f = write_temp_ts(
        r#"
import { build } from "husako";
build([{ _render() { return {
    apiVersion: "apps/v1",
    kind: "Deployment",
    spec: {
        template: {
            spec: {
                containers: [{
                    resources: {
                        requests: { cpu: 1, memory: 2 }
                    }
                }]
            }
        }
    }
}; } }]);
"#,
    );
    husako()
        .args(["render", f.path().to_str().unwrap()])
        .assert()
        .success();
}

// --- Milestone 5: Type Generation + husako generate ---

#[test]
fn generate_skip_k8s() {
    let dir = tempfile::tempdir().unwrap();
    let root = dir.path();

    husako_at(root)
        .args(["generate", "--skip-k8s"])
        .assert()
        .success();

    // Static .d.ts files should exist
    assert!(root.join(".husako/types/husako.d.ts").exists());
    assert!(root.join(".husako/types/husako/_base.d.ts").exists());

    // tsconfig.json should exist with husako paths
    let tsconfig = std::fs::read_to_string(root.join("tsconfig.json")).unwrap();
    let parsed: serde_json::Value = serde_json::from_str(&tsconfig).unwrap();
    assert!(parsed["compilerOptions"]["paths"]["husako"].is_array());
    assert!(parsed["compilerOptions"]["paths"]["k8s/*"].is_array());

    // No k8s/ directory since we skipped k8s types
    assert!(!root.join(".husako/types/k8s").exists());
}

fn write_mock_spec(dir: &Path, group_path: &str) {
    let spec = rich_mock_spec();
    let spec_path = dir.join(format!("{group_path}.json"));
    std::fs::create_dir_all(spec_path.parent().unwrap()).unwrap();
    std::fs::write(spec_path, spec.to_string()).unwrap();
}

fn rich_mock_spec() -> serde_json::Value {
    serde_json::json!({
        "components": {
            "schemas": {
                "io.k8s.api.apps.v1.Deployment": {
                    "description": "Deployment enables declarative updates.",
                    "properties": {
                        "apiVersion": {"type": "string"},
                        "kind": {"type": "string"},
                        "metadata": {"$ref": "#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"},
                        "spec": {"$ref": "#/components/schemas/io.k8s.api.apps.v1.DeploymentSpec"}
                    },
                    "x-kubernetes-group-version-kind": [
                        {"group": "apps", "version": "v1", "kind": "Deployment"}
                    ]
                },
                "io.k8s.api.apps.v1.DeploymentSpec": {
                    "properties": {
                        "replicas": {"type": "integer"},
                        "selector": {"$ref": "#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.LabelSelector"},
                        "strategy": {"$ref": "#/components/schemas/io.k8s.api.apps.v1.DeploymentStrategy"},
                        "template": {"$ref": "#/components/schemas/io.k8s.api.core.v1.PodTemplateSpec"}
                    },
                    "required": ["selector"]
                },
                "io.k8s.api.apps.v1.DeploymentStrategy": {
                    "properties": {
                        "type": {
                            "type": "string",
                            "enum": ["Recreate", "RollingUpdate"]
                        }
                    }
                },
                "io.k8s.api.core.v1.PodTemplateSpec": {
                    "properties": {
                        "spec": {"$ref": "#/components/schemas/io.k8s.api.core.v1.PodSpec"}
                    }
                },
                "io.k8s.api.core.v1.PodSpec": {
                    "properties": {
                        "containers": {
                            "type": "array",
                            "items": {"$ref": "#/components/schemas/io.k8s.api.core.v1.Container"}
                        }
                    }
                },
                "io.k8s.api.core.v1.Container": {
                    "properties": {
                        "name": {"type": "string"},
                        "imagePullPolicy": {
                            "type": "string",
                            "enum": ["Always", "IfNotPresent", "Never"]
                        },
                        "resources": {"$ref": "#/components/schemas/io.k8s.api.core.v1.ResourceRequirements"}
                    }
                },
                "io.k8s.api.core.v1.ResourceRequirements": {
                    "properties": {
                        "limits": {
                            "type": "object",
                            "additionalProperties": {"$ref": "#/components/schemas/io.k8s.apimachinery.pkg.api.resource.Quantity"}
                        },
                        "requests": {
                            "type": "object",
                            "additionalProperties": {"$ref": "#/components/schemas/io.k8s.apimachinery.pkg.api.resource.Quantity"}
                        }
                    }
                },
                "io.k8s.apimachinery.pkg.api.resource.Quantity": {
                    "description": "Quantity is a representation of a decimal number.",
                    "type": "string"
                },
                "io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta": {
                    "description": "Standard object metadata.",
                    "properties": {
                        "name": {"type": "string"},
                        "namespace": {"type": "string"}
                    }
                },
                "io.k8s.apimachinery.pkg.apis.meta.v1.LabelSelector": {
                    "properties": {
                        "matchLabels": {
                            "type": "object",
                            "additionalProperties": {"type": "string"}
                        }
                    }
                }
            }
        }
    })
}

/// Write a `_schema.json` at `.husako/types/k8s/_schema.json` using husako_dts.
fn write_schema_store(root: &Path) {
    let spec = rich_mock_spec();
    let specs = std::collections::HashMap::from([("apis/apps/v1".to_string(), spec)]);
    let store = husako_dts::schema_store::generate_schema_store(&specs);
    let json = serde_json::to_string_pretty(&store).unwrap();
    let schema_dir = root.join(".husako/types/k8s");
    std::fs::create_dir_all(&schema_dir).unwrap();
    std::fs::write(schema_dir.join("_schema.json"), json).unwrap();
}

#[test]
fn generate_spec_dir() {
    let dir = tempfile::tempdir().unwrap();
    let root = dir.path();

    // Create mock spec directory
    let spec_dir = root.join("specs");
    std::fs::create_dir_all(&spec_dir).unwrap();
    write_mock_spec(&spec_dir, "apis/apps/v1");

    husako_at(root)
        .args(["generate", "--spec-dir", spec_dir.to_str().unwrap()])
        .assert()
        .success();

    // Static .d.ts files should exist
    assert!(root.join(".husako/types/husako.d.ts").exists());
    assert!(root.join(".husako/types/husako/_base.d.ts").exists());

    // Generated k8s types should exist (.d.ts and .js)
    assert!(root.join(".husako/types/k8s/_common.d.ts").exists());
    assert!(root.join(".husako/types/k8s/apps/v1.d.ts").exists());
    assert!(root.join(".husako/types/k8s/apps/v1.js").exists());

    // .d.ts should contain Deployment builder (interface + factory)
    let apps_v1 = std::fs::read_to_string(root.join(".husako/types/k8s/apps/v1.d.ts")).unwrap();
    assert!(apps_v1.contains("interface Deployment"));
    assert!(apps_v1.contains("_ResourceBuilder"));

    // .js should contain internal class + factory function
    let apps_v1_js = std::fs::read_to_string(root.join(".husako/types/k8s/apps/v1.js")).unwrap();
    assert!(apps_v1_js.contains("class _Deployment"));
    assert!(apps_v1_js.contains("\"apps/v1\""));

    // tsconfig.json should exist
    assert!(root.join("tsconfig.json").exists());
}

#[test]
fn generate_updates_existing_tsconfig() {
    let dir = tempfile::tempdir().unwrap();
    let root = dir.path();

    // Pre-create tsconfig.json with existing content
    let existing = serde_json::json!({
        "compilerOptions": {
            "strict": true,
            "target": "ES2020",
            "paths": {
                "mylib/*": ["./lib/*"]
            }
        },
        "include": ["src/**/*"]
    });
    std::fs::write(
        root.join("tsconfig.json"),
        serde_json::to_string_pretty(&existing).unwrap(),
    )
    .unwrap();

    husako_at(root)
        .args(["generate", "--skip-k8s"])
        .assert()
        .success();

    let tsconfig = std::fs::read_to_string(root.join("tsconfig.json")).unwrap();
    let parsed: serde_json::Value = serde_json::from_str(&tsconfig).unwrap();

    // Original fields preserved
    assert_eq!(parsed["compilerOptions"]["target"], "ES2020");
    assert!(parsed["include"].is_array());

    // Original path preserved
    assert!(parsed["compilerOptions"]["paths"]["mylib/*"].is_array());

    // husako paths added
    assert!(parsed["compilerOptions"]["paths"]["husako"].is_array());
    assert!(parsed["compilerOptions"]["paths"]["husako/_base"].is_array());
    assert!(parsed["compilerOptions"]["paths"]["k8s/*"].is_array());
}

// --- Milestone 7: Schema-based Validation ---

#[test]
fn schema_invalid_enum_exit_7() {
    let dir = tempfile::tempdir().unwrap();
    let root = dir.path();
    write_schema_store(root);

    let entry = root.join("entry.ts");
    std::fs::write(
        &entry,
        r#"
import { build } from "husako";
build([{ _render() { return {
    apiVersion: "apps/v1",
    kind: "Deployment",
    spec: {
        selector: {},
        strategy: { type: "bluegreen" }
    }
}; } }]);
"#,
    )
    .unwrap();

    husako_at(root)
        .args(["render", entry.to_str().unwrap()])
        .assert()
        .code(7)
        .stderr(predicates::str::contains("invalid value"))
        .stderr(predicates::str::contains("bluegreen"));
}

#[test]
fn schema_type_mismatch_exit_7() {
    let dir = tempfile::tempdir().unwrap();
    let root = dir.path();
    write_schema_store(root);

    let entry = root.join("entry.ts");
    std::fs::write(
        &entry,
        r#"
import { build } from "husako";
build([{ _render() { return {
    apiVersion: "apps/v1",
    kind: "Deployment",
    spec: {
        selector: {},
        replicas: "abc"
    }
}; } }]);
"#,
    )
    .unwrap();

    husako_at(root)
        .args(["render", entry.to_str().unwrap()])
        .assert()
        .code(7)
        .stderr(predicates::str::contains("expected type integer"));
}

#[test]
fn schema_missing_required_exit_7() {
    let dir = tempfile::tempdir().unwrap();
    let root = dir.path();
    write_schema_store(root);

    let entry = root.join("entry.ts");
    std::fs::write(
        &entry,
        r#"
import { build } from "husako";
build([{ _render() { return {
    apiVersion: "apps/v1",
    kind: "Deployment",
    spec: {
        replicas: 3
    }
}; } }]);
"#,
    )
    .unwrap();

    husako_at(root)
        .args(["render", entry.to_str().unwrap()])
        .assert()
        .code(7)
        .stderr(predicates::str::contains("missing required field"));
}

#[test]
fn schema_valid_passes() {
    let dir = tempfile::tempdir().unwrap();
    let root = dir.path();
    write_schema_store(root);

    let entry = root.join("entry.ts");
    std::fs::write(
        &entry,
        r#"
import { build } from "husako";
build([{ _render() { return {
    apiVersion: "apps/v1",
    kind: "Deployment",
    spec: {
        selector: { matchLabels: { app: "test" } },
        replicas: 3,
        strategy: { type: "RollingUpdate" },
        template: {
            spec: {
                containers: [{
                    name: "main",
                    imagePullPolicy: "Always",
                    resources: {
                        requests: { cpu: "500m", memory: "1Gi" },
                        limits: { cpu: "1", memory: "2Gi" }
                    }
                }]
            }
        }
    }
}; } }]);
"#,
    )
    .unwrap();

    husako_at(root)
        .args(["render", entry.to_str().unwrap()])
        .assert()
        .success();
}

#[test]
fn schema_invalid_quantity_exit_7() {
    let dir = tempfile::tempdir().unwrap();
    let root = dir.path();
    write_schema_store(root);

    let entry = root.join("entry.ts");
    std::fs::write(
        &entry,
        r#"
import { build } from "husako";
build([{ _render() { return {
    apiVersion: "apps/v1",
    kind: "Deployment",
    spec: {
        selector: {},
        template: {
            spec: {
                containers: [{
                    resources: {
                        requests: { cpu: "2gb" }
                    }
                }]
            }
        }
    }
}; } }]);
"#,
    )
    .unwrap();

    husako_at(root)
        .args(["render", entry.to_str().unwrap()])
        .assert()
        .code(7)
        .stderr(predicates::str::contains("invalid quantity"))
        .stderr(predicates::str::contains("2gb"));
}

// --- Milestone 8: Safety & Diagnostics ---

#[test]
fn timeout_infinite_loop_exit_4() {
    let f = write_temp_ts(
        r#"
import { build } from "husako";
while(true) {}
build([]);
"#,
    );
    husako()
        .args(["render", "--timeout-ms", "100", f.path().to_str().unwrap()])
        .assert()
        .code(4)
        .stderr(predicates::str::contains("timed out"));
}

#[test]
fn memory_limit_exit_4() {
    let f = write_temp_ts(
        r#"
import { build } from "husako";
const arr = [];
for (let i = 0; i < 10000000; i++) { arr.push(new Array(1000)); }
build([]);
"#,
    );
    husako()
        .args(["render", "--max-heap-mb", "1", f.path().to_str().unwrap()])
        .assert()
        .code(4)
        .stderr(predicates::str::contains("memory limit"));
}

#[test]
fn timeout_does_not_interfere_with_normal_script() {
    let f = write_temp_ts(
        r#"
import { build } from "husako";
build([{ _render() { return { apiVersion: "v1", kind: "Namespace", metadata: { name: "test" } }; } }]);
"#,
    );
    husako()
        .args(["render", "--timeout-ms", "5000", f.path().to_str().unwrap()])
        .assert()
        .success()
        .stdout(predicates::str::contains("kind: Namespace"));
}

#[test]
fn verbose_produces_stderr_output() {
    let f = write_temp_ts(
        r#"
import { build } from "husako";
build([{ _render() { return { apiVersion: "v1", kind: "Namespace", metadata: { name: "test" } }; } }]);
"#,
    );
    husako()
        .args(["render", "--verbose", f.path().to_str().unwrap()])
        .assert()
        .success()
        .stderr(predicates::str::contains("[compile]"))
        .stderr(predicates::str::contains("[execute]"))
        .stderr(predicates::str::contains("[validate]"))
        .stderr(predicates::str::contains("[emit]"));
}

#[test]
fn generate_creates_schema_json() {
    let dir = tempfile::tempdir().unwrap();
    let root = dir.path();

    let spec_dir = root.join("specs");
    std::fs::create_dir_all(&spec_dir).unwrap();
    write_mock_spec(&spec_dir, "apis/apps/v1");

    husako_at(root)
        .args(["generate", "--spec-dir", spec_dir.to_str().unwrap()])
        .assert()
        .success();

    // _schema.json should exist (replaces _validation.json)
    assert!(root.join(".husako/types/k8s/_schema.json").exists());

    // Check basic structure
    let content = std::fs::read_to_string(root.join(".husako/types/k8s/_schema.json")).unwrap();
    let parsed: serde_json::Value = serde_json::from_str(&content).unwrap();
    assert_eq!(parsed["version"], 2);
    assert!(parsed["gvk_index"].is_object());
    assert!(parsed["schemas"].is_object());
}

// --- husako new ---

#[test]
fn new_simple_creates_project() {
    let dir = tempfile::tempdir().unwrap();
    let target = dir.path().join("my-app");

    husako()
        .args(["new", target.to_str().unwrap()])
        .assert()
        .success()
        .stderr(predicates::str::contains("Created 'simple' project"))
        .stderr(predicates::str::contains("husako generate"));

    assert!(target.join(".gitignore").exists());
    assert!(target.join("husako.toml").exists());
    assert!(target.join("entry.ts").exists());
}

#[test]
fn new_project_template() {
    let dir = tempfile::tempdir().unwrap();
    let target = dir.path().join("my-app");

    husako()
        .args(["new", "--template", "project", target.to_str().unwrap()])
        .assert()
        .success()
        .stderr(predicates::str::contains("Created 'project' project"));

    assert!(target.join(".gitignore").exists());
    assert!(target.join("husako.toml").exists());
    assert!(target.join("env/dev.ts").exists());
    assert!(target.join("deployments/nginx.ts").exists());
    assert!(target.join("lib/index.ts").exists());
    assert!(target.join("lib/metadata.ts").exists());
}

#[test]
fn new_multi_env_template() {
    let dir = tempfile::tempdir().unwrap();
    let target = dir.path().join("my-app");

    husako()
        .args(["new", "--template", "multi-env", target.to_str().unwrap()])
        .assert()
        .success()
        .stderr(predicates::str::contains("Created 'multi-env' project"));

    assert!(target.join(".gitignore").exists());
    assert!(target.join("husako.toml").exists());
    assert!(target.join("base/nginx.ts").exists());
    assert!(target.join("base/service.ts").exists());
    assert!(target.join("dev/main.ts").exists());
    assert!(target.join("staging/main.ts").exists());
    assert!(target.join("release/main.ts").exists());
}

#[test]
fn new_rejects_nonempty_dir() {
    let dir = tempfile::tempdir().unwrap();
    let target = dir.path().join("my-app");
    std::fs::create_dir_all(&target).unwrap();
    std::fs::write(target.join("existing.txt"), "content").unwrap();

    husako()
        .args(["new", target.to_str().unwrap()])
        .assert()
        .code(1)
        .stderr(predicates::str::contains("not empty"));
}

#[test]
fn new_then_render_simple() {
    let dir = tempfile::tempdir().unwrap();
    let target = dir.path().join("my-app");

    // Scaffold
    husako()
        .args(["new", target.to_str().unwrap()])
        .assert()
        .success();

    // Write k8s modules for rendering
    write_k8s_modules(&target);

    // Render
    husako_at(&target)
        .args(["render", target.join("entry.ts").to_str().unwrap()])
        .assert()
        .success()
        .stdout(predicates::str::contains("apiVersion: apps/v1"))
        .stdout(predicates::str::contains("kind: Deployment"))
        .stdout(predicates::str::contains("name: nginx"));
}

#[test]
fn new_then_render_project() {
    let dir = tempfile::tempdir().unwrap();
    let target = dir.path().join("my-app");

    // Scaffold
    husako()
        .args(["new", "--template", "project", target.to_str().unwrap()])
        .assert()
        .success();

    // Write k8s modules for rendering
    write_k8s_modules(&target);

    // Render
    husako_at(&target)
        .args(["render", target.join("env/dev.ts").to_str().unwrap()])
        .assert()
        .success()
        .stdout(predicates::str::contains("apiVersion: apps/v1"))
        .stdout(predicates::str::contains("kind: Deployment"))
        .stdout(predicates::str::contains("name: nginx"));
}

#[test]
fn new_then_render_multi_env() {
    let dir = tempfile::tempdir().unwrap();
    let target = dir.path().join("my-app");

    // Scaffold
    husako()
        .args(["new", "--template", "multi-env", target.to_str().unwrap()])
        .assert()
        .success();

    // Write k8s modules for rendering
    write_k8s_modules(&target);

    // Render dev
    let dev_output = husako_at(&target)
        .args(["render", target.join("dev/main.ts").to_str().unwrap()])
        .output()
        .unwrap();
    assert!(dev_output.status.success());
    let dev_yaml = String::from_utf8(dev_output.stdout).unwrap();
    assert!(dev_yaml.contains("namespace: dev"));
    assert!(dev_yaml.contains("replicas: 1"));
    assert!(dev_yaml.contains("image: nginx:latest"));

    // Render release
    let release_output = husako_at(&target)
        .args(["render", target.join("release/main.ts").to_str().unwrap()])
        .output()
        .unwrap();
    assert!(release_output.status.success());
    let release_yaml = String::from_utf8(release_output.stdout).unwrap();
    assert!(release_yaml.contains("namespace: release"));
    assert!(release_yaml.contains("replicas: 3"));
    assert!(release_yaml.contains("image: nginx:1.25"));
}

// --- Milestone 8 (Dynamic K8s Resources): New tests ---

#[test]
fn render_k8s_import_without_generate() {
    let dir = tempfile::tempdir().unwrap();
    let root = dir.path();

    let entry = root.join("entry.ts");
    std::fs::write(
        &entry,
        r#"
import { build } from "husako";
import { Deployment } from "k8s/apps/v1";
build([Deployment()]);
"#,
    )
    .unwrap();

    husako_at(root)
        .args(["render", entry.to_str().unwrap()])
        .assert()
        .code(4)
        .stderr(predicates::str::contains("husako generate"));
}

#[test]
fn generate_creates_js_modules() {
    let dir = tempfile::tempdir().unwrap();
    let root = dir.path();

    let spec_dir = root.join("specs");
    std::fs::create_dir_all(&spec_dir).unwrap();
    write_mock_spec(&spec_dir, "apis/apps/v1");

    husako_at(root)
        .args(["generate", "--spec-dir", spec_dir.to_str().unwrap()])
        .assert()
        .success();

    // .js should exist alongside .d.ts
    assert!(root.join(".husako/types/k8s/apps/v1.js").exists());

    let js = std::fs::read_to_string(root.join(".husako/types/k8s/apps/v1.js")).unwrap();
    assert!(js.contains("class _Deployment"));
    assert!(js.contains("_ResourceBuilder"));
}

#[test]
fn render_with_generated_modules() {
    let dir = tempfile::tempdir().unwrap();
    let root = dir.path();

    // Generate via husako generate
    let spec_dir = root.join("specs");
    std::fs::create_dir_all(&spec_dir).unwrap();
    write_mock_spec(&spec_dir, "apis/apps/v1");

    husako_at(root)
        .args(["generate", "--spec-dir", spec_dir.to_str().unwrap()])
        .assert()
        .success();

    // Now render using generated modules
    let entry = root.join("entry.ts");
    std::fs::write(
        &entry,
        r#"
import { build, name } from "husako";
import { Deployment } from "k8s/apps/v1";
const d = Deployment().metadata(name("test"));
build([d]);
"#,
    )
    .unwrap();

    husako_at(root)
        .args(["render", entry.to_str().unwrap()])
        .assert()
        .success()
        .stdout(predicates::str::contains("apiVersion: apps/v1"))
        .stdout(predicates::str::contains("kind: Deployment"))
        .stdout(predicates::str::contains("name: test"));
}

#[test]
fn generic_spec_setter() {
    let (dir, entry) = project_with_k8s(
        r#"
import { build, name } from "husako";
import { Namespace } from "k8s/core/v1";
const ns = Namespace()
    .metadata(name("my-ns"))
    .spec({ finalizers: ["kubernetes"] });
build([ns]);
"#,
    );
    husako_at(dir.path())
        .args(["render", entry.to_str().unwrap()])
        .assert()
        .success()
        .stdout(predicates::str::contains("kind: Namespace"))
        .stdout(predicates::str::contains("name: my-ns"))
        .stdout(predicates::str::contains("finalizers"));
}

#[test]
fn generic_set_configmap() {
    let (dir, entry) = project_with_k8s(
        r#"
import { build, name } from "husako";
import { ConfigMap } from "k8s/core/v1";
const cm = ConfigMap()
    .metadata(name("my-config"))
    .data({ key1: "val1", key2: "val2" });
build([cm]);
"#,
    );
    husako_at(dir.path())
        .args(["render", entry.to_str().unwrap()])
        .assert()
        .success()
        .stdout(predicates::str::contains("kind: ConfigMap"))
        .stdout(predicates::str::contains("key1: val1"))
        .stdout(predicates::str::contains("key2: val2"));
}

// --- Generic Builder Pattern ---

#[test]
fn builder_spec_property_methods() {
    let (dir, entry) = project_with_k8s(
        r#"
import { build, metadata } from "husako";
import { Deployment } from "k8s/apps/v1";
import { Container } from "k8s/core/v1";
import { LabelSelector } from "k8s/_common";
const d = Deployment()
    .metadata(metadata().name("nginx").label("app", "nginx"))
    .replicas(3)
    .selector(LabelSelector().matchLabels({ app: "nginx" }))
    .containers([
        Container().name("nginx").image("nginx:1.25")
    ]);
build([d]);
"#,
    );
    husako_at(dir.path())
        .args(["render", entry.to_str().unwrap()])
        .assert()
        .success()
        .stdout(predicates::str::contains("apiVersion: apps/v1"))
        .stdout(predicates::str::contains("kind: Deployment"))
        .stdout(predicates::str::contains("name: nginx"))
        .stdout(predicates::str::contains("replicas: 3"))
        .stdout(predicates::str::contains("app: nginx"))
        .stdout(predicates::str::contains("image: nginx:1.25"));
}

#[test]
fn builder_set_deep_merges() {
    let (dir, entry) = project_with_k8s(
        r#"
import { build, name } from "husako";
import { Deployment } from "k8s/apps/v1";
import { Container } from "k8s/core/v1";
const d = Deployment()
    .metadata(name("nginx"))
    .replicas(2)
    .containers([Container().name("nginx").image("nginx:1.25")])
    .initContainers([Container().name("init").image("busybox")]);
build([d]);
"#,
    );
    let output = husako_at(dir.path())
        .args(["render", entry.to_str().unwrap()])
        .output()
        .unwrap();
    assert!(output.status.success());
    let yaml = String::from_utf8(output.stdout).unwrap();
    // Both containers and initContainers should exist under template.spec
    assert!(yaml.contains("name: nginx"));
    assert!(yaml.contains("image: nginx:1.25"));
    assert!(yaml.contains("name: init"));
    assert!(yaml.contains("image: busybox"));
    assert!(yaml.contains("replicas: 2"));
}

#[test]
fn builder_spec_overrides_spec_parts() {
    let (dir, entry) = project_with_k8s(
        r#"
import { build, name } from "husako";
import { Deployment } from "k8s/apps/v1";
// .spec() should override any _specParts set via .replicas()
const d = Deployment()
    .metadata(name("nginx"))
    .replicas(3)
    .spec({ replicas: 5, selector: {} });
build([d]);
"#,
    );
    let output = husako_at(dir.path())
        .args(["render", entry.to_str().unwrap()])
        .output()
        .unwrap();
    assert!(output.status.success());
    let yaml = String::from_utf8(output.stdout).unwrap();
    // .spec() wins over .replicas()
    assert!(yaml.contains("replicas: 5"));
    assert!(!yaml.contains("replicas: 3"));
}

#[test]
fn builder_spec_parts_and_resources_merge() {
    let (dir, entry) = project_with_k8s(
        r#"
import { build, name, cpu, memory, requests, limits } from "husako";
import { Deployment } from "k8s/apps/v1";
import { Container } from "k8s/core/v1";
import { LabelSelector } from "k8s/_common";
// _specParts (from .replicas/.containers) and _resources should merge
const d = Deployment()
    .metadata(name("nginx"))
    .replicas(2)
    .selector(LabelSelector().matchLabels({ app: "nginx" }))
    .containers([
        Container().name("nginx").image("nginx:1.25")
            .resources(requests(cpu("250m").memory("128Mi")).limits(cpu("500m").memory("256Mi")))
    ]);
build([d]);
"#,
    );
    let output = husako_at(dir.path())
        .args(["render", entry.to_str().unwrap()])
        .output()
        .unwrap();
    assert!(output.status.success());
    let yaml = String::from_utf8(output.stdout).unwrap();
    // Both specParts and resources should be present
    assert!(yaml.contains("replicas: 2"));
    assert!(yaml.contains("image: nginx:1.25"));
    assert!(yaml.contains("cpu: 250m"));
    assert!(yaml.contains("memory: 128Mi"));
    assert!(yaml.contains("cpu: 500m"));
    assert!(yaml.contains("memory: 256Mi"));
}

#[test]
fn builder_copy_on_write_isolation() {
    let (dir, entry) = project_with_k8s(
        r#"
import { build, name } from "husako";
import { Deployment } from "k8s/apps/v1";
const base = Deployment().metadata(name("base")).replicas(1);
const a = base.replicas(3);
const b = base.replicas(5);
build([a, b]);
"#,
    );
    let output = husako_at(dir.path())
        .args(["render", entry.to_str().unwrap()])
        .output()
        .unwrap();
    assert!(output.status.success());
    let yaml = String::from_utf8(output.stdout).unwrap();
    assert!(yaml.contains("replicas: 3"));
    assert!(yaml.contains("replicas: 5"));
    // base's replicas=1 should not appear
    assert!(!yaml.contains("replicas: 1"));
}

#[test]
fn builder_service_spec_properties() {
    let (dir, entry) = project_with_k8s(
        r#"
import { build, name } from "husako";
import { Service } from "k8s/core/v1";
const svc = Service()
    .metadata(name("nginx"))
    .selector({ app: "nginx" })
    .ports([{ port: 80, targetPort: 8080 }])
    .type("ClusterIP");
build([svc]);
"#,
    );
    husako_at(dir.path())
        .args(["render", entry.to_str().unwrap()])
        .assert()
        .success()
        .stdout(predicates::str::contains("kind: Service"))
        .stdout(predicates::str::contains("app: nginx"))
        .stdout(predicates::str::contains("port: 80"))
        .stdout(predicates::str::contains("targetPort: 8080"))
        .stdout(predicates::str::contains("type: ClusterIP"));
}

// --- husako.toml entry aliases ---

#[test]
fn render_with_entry_alias() {
    let dir = tempfile::tempdir().unwrap();
    let root = dir.path();

    // Create husako.toml with an entry alias
    std::fs::write(
        root.join("husako.toml"),
        r#"
[entries]
dev = "env/dev.ts"

[schemas]
kubernetes = { source = "release", version = "1.35" }
"#,
    )
    .unwrap();

    // Create the entry file
    std::fs::create_dir_all(root.join("env")).unwrap();
    std::fs::write(
        root.join("env/dev.ts"),
        r#"
import { build } from "husako";
build([{ _render() { return { apiVersion: "v1", kind: "Namespace", metadata: { name: "dev" } }; } }]);
"#,
    )
    .unwrap();

    // Render using alias
    husako_at(root)
        .args(["render", "dev"])
        .assert()
        .success()
        .stdout(predicates::str::contains("kind: Namespace"))
        .stdout(predicates::str::contains("name: dev"));
}

#[test]
fn render_alias_file_not_found() {
    let dir = tempfile::tempdir().unwrap();
    let root = dir.path();

    std::fs::write(
        root.join("husako.toml"),
        r#"
[entries]
dev = "env/dev.ts"
"#,
    )
    .unwrap();

    // File doesn't exist  should show which file the alias maps to
    husako_at(root)
        .args(["render", "dev"])
        .assert()
        .code(2)
        .stderr(predicates::str::contains("env/dev.ts"))
        .stderr(predicates::str::contains("not found"));
}

#[test]
fn render_unknown_alias_lists_available() {
    let dir = tempfile::tempdir().unwrap();
    let root = dir.path();

    std::fs::write(
        root.join("husako.toml"),
        r#"
[entries]
dev = "env/dev.ts"
staging = "env/staging.ts"
"#,
    )
    .unwrap();

    // Unknown alias  should list available aliases
    husako_at(root)
        .args(["render", "unknown"])
        .assert()
        .code(2)
        .stderr(predicates::str::contains("not a file or entry alias"))
        .stderr(predicates::str::contains("dev"))
        .stderr(predicates::str::contains("staging"));
}

#[test]
fn render_direct_path_still_works_with_config() {
    let dir = tempfile::tempdir().unwrap();
    let root = dir.path();

    // Config exists but we use direct path
    std::fs::write(
        root.join("husako.toml"),
        r#"
[entries]
alias = "other.ts"
"#,
    )
    .unwrap();

    std::fs::write(
        root.join("entry.ts"),
        r#"
import { build } from "husako";
build([{ _render() { return { apiVersion: "v1", kind: "Namespace", metadata: { name: "test" } }; } }]);
"#,
    )
    .unwrap();

    // Direct path still works
    husako_at(root)
        .args(["render", "entry.ts"])
        .assert()
        .success()
        .stdout(predicates::str::contains("kind: Namespace"));
}

#[test]
fn render_no_config_direct_path_works() {
    let dir = tempfile::tempdir().unwrap();
    let root = dir.path();

    // No husako.toml  direct path must still work
    std::fs::write(
        root.join("entry.ts"),
        r#"
import { build } from "husako";
build([{ _render() { return { apiVersion: "v1", kind: "Namespace", metadata: { name: "test" } }; } }]);
"#,
    )
    .unwrap();

    husako_at(root)
        .args(["render", "entry.ts"])
        .assert()
        .success()
        .stdout(predicates::str::contains("kind: Namespace"));
}

// --- render --output ---

const SIMPLE_NAMESPACE_TS: &str = r#"
import { build } from "husako";
build([{ _render() { return { apiVersion: "v1", kind: "Namespace", metadata: { name: "out" } }; } }]);
"#;

#[test]
fn render_output_to_yaml_file() {
    let dir = tempfile::tempdir().unwrap();
    let root = dir.path();
    std::fs::write(root.join("entry.ts"), SIMPLE_NAMESPACE_TS).unwrap();
    let out = root.join("out.yaml");

    husako_at(root)
        .args(["render", "entry.ts", "--output", out.to_str().unwrap()])
        .assert()
        .success()
        .stdout("")
        .stderr(predicates::str::contains("Written to"));

    let contents = std::fs::read_to_string(&out).unwrap();
    assert!(contents.contains("kind: Namespace"));
}

#[test]
fn render_output_to_dir_uses_stem() {
    let dir = tempfile::tempdir().unwrap();
    let root = dir.path();
    std::fs::write(root.join("entry.ts"), SIMPLE_NAMESPACE_TS).unwrap();
    let out_dir = root.join("dist");

    husako_at(root)
        .args(["render", "entry.ts", "--output", out_dir.to_str().unwrap()])
        .assert()
        .success()
        .stdout("");

    let out_file = out_dir.join("entry.yaml");
    let contents = std::fs::read_to_string(&out_file).unwrap();
    assert!(contents.contains("kind: Namespace"));
}

#[test]
fn render_output_alias_preserves_path() {
    let dir = tempfile::tempdir().unwrap();
    let root = dir.path();

    std::fs::write(
        root.join("husako.toml"),
        "[entries]\n\"apps/my-app\" = \"src/apps/my-app.ts\"\n",
    )
    .unwrap();
    std::fs::create_dir_all(root.join("src/apps")).unwrap();
    std::fs::write(root.join("src/apps/my-app.ts"), SIMPLE_NAMESPACE_TS).unwrap();
    let out_dir = root.join("dist");

    husako_at(root)
        .args([
            "render",
            "apps/my-app",
            "--output",
            out_dir.to_str().unwrap(),
        ])
        .assert()
        .success()
        .stdout("");

    // alias "apps/my-app"  dist/apps/my-app.yaml
    let out_file = out_dir.join("apps").join("my-app.yaml");
    let contents = std::fs::read_to_string(&out_file).unwrap();
    assert!(contents.contains("kind: Namespace"));
}

#[test]
fn render_output_creates_nested_dirs() {
    let dir = tempfile::tempdir().unwrap();
    let root = dir.path();
    std::fs::write(root.join("entry.ts"), SIMPLE_NAMESPACE_TS).unwrap();
    let out = root.join("a").join("b").join("c").join("out.yaml");

    husako_at(root)
        .args(["render", "entry.ts", "--output", out.to_str().unwrap()])
        .assert()
        .success();

    assert!(out.exists());
}

#[test]
fn render_output_overwrites_existing() {
    let dir = tempfile::tempdir().unwrap();
    let root = dir.path();
    std::fs::write(root.join("entry.ts"), SIMPLE_NAMESPACE_TS).unwrap();
    let out = root.join("out.yaml");
    std::fs::write(&out, "old content").unwrap();

    husako_at(root)
        .args(["render", "entry.ts", "--output", out.to_str().unwrap()])
        .assert()
        .success();

    let contents = std::fs::read_to_string(&out).unwrap();
    assert!(contents.contains("kind: Namespace"));
    assert!(!contents.contains("old content"));
}

#[test]
fn new_creates_husako_toml() {
    let dir = tempfile::tempdir().unwrap();
    let target = dir.path().join("my-app");

    husako()
        .args(["new", target.to_str().unwrap()])
        .assert()
        .success();

    assert!(target.join("husako.toml").exists());
    let content = std::fs::read_to_string(target.join("husako.toml")).unwrap();
    assert!(content.contains("[resources]"));
    assert!(content.contains("source = \"release\""));
}

#[test]
fn new_project_creates_husako_toml_with_entries() {
    let dir = tempfile::tempdir().unwrap();
    let target = dir.path().join("my-app");

    husako()
        .args(["new", "--template", "project", target.to_str().unwrap()])
        .assert()
        .success();

    let content = std::fs::read_to_string(target.join("husako.toml")).unwrap();
    assert!(content.contains("[entries]"));
    assert!(content.contains("dev"));
}

#[test]
fn new_multi_env_creates_husako_toml_with_entries() {
    let dir = tempfile::tempdir().unwrap();
    let target = dir.path().join("my-app");

    husako()
        .args(["new", "--template", "multi-env", target.to_str().unwrap()])
        .assert()
        .success();

    let content = std::fs::read_to_string(target.join("husako.toml")).unwrap();
    assert!(content.contains("[entries]"));
    assert!(content.contains("dev"));
    assert!(content.contains("staging"));
    assert!(content.contains("release"));
}

#[test]
fn new_then_render_with_alias() {
    let dir = tempfile::tempdir().unwrap();
    let target = dir.path().join("my-app");

    // Scaffold project template (has [entries] dev = "env/dev.ts")
    husako()
        .args(["new", "--template", "project", target.to_str().unwrap()])
        .assert()
        .success();

    // Write k8s modules for rendering
    write_k8s_modules(&target);

    // Render using the alias "dev" instead of "env/dev.ts"
    husako_at(&target)
        .args(["render", "dev"])
        .assert()
        .success()
        .stdout(predicates::str::contains("apiVersion: apps/v1"))
        .stdout(predicates::str::contains("kind: Deployment"))
        .stdout(predicates::str::contains("name: nginx"));
}

// --- Plugin System ---

/// Create a minimal fixture plugin under `root/.husako/plugins/<name>/`.
fn write_fixture_plugin(root: &Path, name: &str) {
    let plugin_dir = root.join(format!(".husako/plugins/{name}"));
    let modules_dir = plugin_dir.join("modules");
    std::fs::create_dir_all(&modules_dir).unwrap();

    std::fs::write(
        plugin_dir.join("plugin.toml"),
        format!(
            r#"[plugin]
name = "{name}"
version = "0.1.0"
description = "Test fixture plugin"

[modules]
"{name}" = "modules/index.js"
"{name}/sub" = "modules/sub.js"
"#
        ),
    )
    .unwrap();

    // Main module: exports a ResourceBuilder subclass
    std::fs::write(
        modules_dir.join("index.js"),
        r#"import { _ResourceBuilder } from "husako/_base";

class _TestResource extends _ResourceBuilder {
  constructor() { super("test.example.com/v1", "TestResource"); }
  message(v) { return this._setSpec("message", v); }
}
export function TestResource() { return new _TestResource(); }
"#,
    )
    .unwrap();

    // Sub-module
    std::fs::write(
        modules_dir.join("sub.js"),
        r#"import { _ResourceBuilder } from "husako/_base";

class _SubResource extends _ResourceBuilder {
  constructor() { super("test.example.com/v1", "SubResource"); }
  count(v) { return this._setSpec("count", v); }
}
export function SubResource() { return new _SubResource(); }
"#,
    )
    .unwrap();
}

#[test]
fn plugin_render_main_module() {
    let dir = tempfile::tempdir().unwrap();
    let root = dir.path();

    write_fixture_plugin(root, "testplugin");

    let entry = root.join("entry.ts");
    std::fs::write(
        &entry,
        r#"
import { build, name } from "husako";
import { TestResource } from "testplugin";
const r = TestResource().metadata(name("my-resource")).message("hello");
build([r]);
"#,
    )
    .unwrap();

    husako_at(root)
        .args(["render", entry.to_str().unwrap()])
        .assert()
        .success()
        .stdout(predicates::str::contains("apiVersion: test.example.com/v1"))
        .stdout(predicates::str::contains("kind: TestResource"))
        .stdout(predicates::str::contains("name: my-resource"))
        .stdout(predicates::str::contains("message: hello"));
}

#[test]
fn plugin_render_sub_module() {
    let dir = tempfile::tempdir().unwrap();
    let root = dir.path();

    write_fixture_plugin(root, "testplugin");

    let entry = root.join("entry.ts");
    std::fs::write(
        &entry,
        r#"
import { build, name } from "husako";
import { SubResource } from "testplugin/sub";
const r = SubResource().metadata(name("sub")).count(42);
build([r]);
"#,
    )
    .unwrap();

    husako_at(root)
        .args(["render", entry.to_str().unwrap()])
        .assert()
        .success()
        .stdout(predicates::str::contains("apiVersion: test.example.com/v1"))
        .stdout(predicates::str::contains("kind: SubResource"))
        .stdout(predicates::str::contains("count: 42"));
}

#[test]
fn plugin_import_unknown_module_exit_4() {
    let dir = tempfile::tempdir().unwrap();
    let root = dir.path();

    // No plugins installed  bare import should fail at runtime
    let entry = root.join("entry.ts");
    std::fs::write(
        &entry,
        r#"
import { build } from "husako";
import { Foo } from "nonexistent-plugin";
build([Foo()]);
"#,
    )
    .unwrap();

    husako_at(root)
        .args(["render", entry.to_str().unwrap()])
        .assert()
        .code(4);
}

#[test]
fn plugin_with_k8s_modules_together() {
    let dir = tempfile::tempdir().unwrap();
    let root = dir.path();

    write_fixture_plugin(root, "testplugin");
    write_k8s_modules(root);

    let entry = root.join("entry.ts");
    std::fs::write(
        &entry,
        r#"
import { build, name } from "husako";
import { Deployment } from "k8s/apps/v1";
import { TestResource } from "testplugin";

const dep = Deployment().metadata(name("app")).replicas(3);
const res = TestResource().metadata(name("my-res")).message("world");
build([dep, res]);
"#,
    )
    .unwrap();

    husako_at(root)
        .args(["render", entry.to_str().unwrap()])
        .assert()
        .success()
        .stdout(predicates::str::contains("kind: Deployment"))
        .stdout(predicates::str::contains("kind: TestResource"))
        .stdout(predicates::str::contains("message: world"));
}

#[test]
fn plugin_cli_list_empty() {
    let dir = tempfile::tempdir().unwrap();

    husako_at(dir.path())
        .args(["plugin", "list"])
        .assert()
        .success()
        .stderr(predicates::str::contains("No plugins installed"));
}

#[test]
fn plugin_cli_list_installed() {
    let dir = tempfile::tempdir().unwrap();
    let root = dir.path();

    write_fixture_plugin(root, "myplugin");

    husako_at(root)
        .args(["plugin", "list"])
        .assert()
        .success()
        .stderr(predicates::str::contains("myplugin"))
        .stderr(predicates::str::contains("0.1.0"));
}

#[test]
fn plugin_cli_add_path_and_remove() {
    let dir = tempfile::tempdir().unwrap();
    let root = dir.path();

    // Create husako.toml
    std::fs::write(root.join("husako.toml"), "").unwrap();

    // Create a local plugin source
    let plugin_src = root.join("my-plugin");
    std::fs::create_dir_all(&plugin_src).unwrap();
    std::fs::write(
        plugin_src.join("plugin.toml"),
        "[plugin]\nname = \"test\"\nversion = \"0.1.0\"\n",
    )
    .unwrap();

    // Add the plugin
    husako_at(root)
        .args(["plugin", "add", "test", "--path", "my-plugin"])
        .assert()
        .success();

    // Verify it was added to husako.toml
    let config_content = std::fs::read_to_string(root.join("husako.toml")).unwrap();
    assert!(config_content.contains("[plugins]"));
    assert!(config_content.contains("test"));
    assert!(config_content.contains("my-plugin"));

    // Remove the plugin
    husako_at(root)
        .args(["plugin", "remove", "test"])
        .assert()
        .success();

    // Verify it was removed from husako.toml
    let config_content = std::fs::read_to_string(root.join("husako.toml")).unwrap();
    assert!(!config_content.contains("test"));
}

// --- FluxCD Plugin ---

/// Install the bundled fluxcd plugin into `.husako/plugins/fluxcd/` for test isolation.
fn install_flux_plugin(root: &Path) {
    let plugin_dir = root.join(".husako/plugins/fluxcd");
    let modules_dir = plugin_dir.join("modules");
    std::fs::create_dir_all(&modules_dir).unwrap();

    std::fs::write(
        plugin_dir.join("plugin.toml"),
        include_str!("../../../plugins/fluxcd/plugin.toml"),
    )
    .unwrap();
    std::fs::write(
        modules_dir.join("source.js"),
        include_str!("../../../plugins/fluxcd/modules/source.js"),
    )
    .unwrap();
    std::fs::write(
        modules_dir.join("index.js"),
        include_str!("../../../plugins/fluxcd/modules/index.js"),
    )
    .unwrap();
}

#[test]
fn flux_plugin_helm_release() {
    let dir = tempfile::tempdir().unwrap();
    let root = dir.path();

    install_flux_plugin(root);

    let entry = root.join("entry.ts");
    std::fs::write(
        &entry,
        r#"
import { build, name, namespace } from "husako";
import { HelmRelease, HelmRepository } from "fluxcd";

const repo = HelmRepository()
    .metadata(name("bitnami").namespace("flux-system"))
    .url("https://charts.bitnami.com/bitnami")
    .interval("1h");

const release = HelmRelease()
    .metadata(name("redis").namespace("default"))
    .chart("redis", "18.0.0")
    .sourceRef(repo)
    .interval("5m")
    .values({ architecture: "standalone" });

build([repo, release]);
"#,
    )
    .unwrap();

    husako_at(root)
        .args(["render", entry.to_str().unwrap()])
        .assert()
        .success()
        .stdout(predicates::str::contains(
            "apiVersion: source.toolkit.fluxcd.io/v1",
        ))
        .stdout(predicates::str::contains("kind: HelmRepository"))
        .stdout(predicates::str::contains("name: bitnami"))
        .stdout(predicates::str::contains(
            "apiVersion: helm.toolkit.fluxcd.io/v2",
        ))
        .stdout(predicates::str::contains("kind: HelmRelease"))
        .stdout(predicates::str::contains("name: redis"))
        .stdout(predicates::str::contains("chart: redis"))
        .stdout(predicates::str::contains("version: 18.0.0"))
        .stdout(predicates::str::contains("architecture: standalone"));
}

#[test]
fn flux_plugin_kustomization() {
    let dir = tempfile::tempdir().unwrap();
    let root = dir.path();

    install_flux_plugin(root);

    let entry = root.join("entry.ts");
    std::fs::write(
        &entry,
        r#"
import { build, name, namespace } from "husako";
import { Kustomization } from "fluxcd";
import { GitRepository } from "fluxcd/source";

const repo = GitRepository()
    .metadata(name("infra").namespace("flux-system"))
    .url("https://github.com/example/infra")
    .ref({ branch: "main" })
    .interval("5m");

const ks = Kustomization()
    .metadata(name("infra").namespace("flux-system"))
    .sourceRef(repo)
    .path("./clusters/production")
    .interval("10m")
    .prune(true)
    .targetNamespace("default");

build([repo, ks]);
"#,
    )
    .unwrap();

    husako_at(root)
        .args(["render", entry.to_str().unwrap()])
        .assert()
        .success()
        .stdout(predicates::str::contains(
            "apiVersion: source.toolkit.fluxcd.io/v1",
        ))
        .stdout(predicates::str::contains("kind: GitRepository"))
        .stdout(predicates::str::contains("name: infra"))
        .stdout(predicates::str::contains(
            "apiVersion: kustomize.toolkit.fluxcd.io/v1",
        ))
        .stdout(predicates::str::contains("kind: Kustomization"))
        .stdout(predicates::str::contains("path: ./clusters/production"))
        .stdout(predicates::str::contains("prune: true"))
        .stdout(predicates::str::contains("targetNamespace: default"));
}

#[test]
fn flux_plugin_source_ref_linking() {
    let dir = tempfile::tempdir().unwrap();
    let root = dir.path();

    install_flux_plugin(root);

    let entry = root.join("entry.ts");
    std::fs::write(
        &entry,
        r#"
import { build, name, namespace } from "husako";
import { HelmRelease, HelmRepository } from "fluxcd";

const repo = HelmRepository("charts")
    .metadata(name("charts").namespace("flux-system"))
    .url("https://charts.example.com")
    .interval("1h");

const release = HelmRelease("app")
    .chart("my-app", "1.0.0")
    .sourceRef(repo);

build([release]);
"#,
    )
    .unwrap();

    let output = husako_at(root)
        .args(["render", entry.to_str().unwrap()])
        .output()
        .unwrap();
    assert!(output.status.success());
    let yaml = String::from_utf8(output.stdout).unwrap();
    // sourceRef should be resolved from the HelmRepository builder
    assert!(yaml.contains("kind: HelmRepository"));
    assert!(yaml.contains("name: charts"));
    assert!(yaml.contains("namespace: flux-system"));
}

#[test]
fn flux_plugin_values_plain_object() {
    let dir = tempfile::tempdir().unwrap();
    let root = dir.path();

    install_flux_plugin(root);

    let entry = root.join("entry.ts");
    std::fs::write(
        &entry,
        r#"
import { build, name } from "husako";
import { HelmRelease } from "fluxcd";

const release = HelmRelease("app")
    .chart("my-app", 2.0)
    .values({ replicas: 3, image: { tag: "latest" } });

build([release]);
"#,
    )
    .unwrap();

    husako_at(root)
        .args(["render", entry.to_str().unwrap()])
        .assert()
        .success()
        .stdout(predicates::str::contains("kind: HelmRelease"))
        .stdout(predicates::str::contains("chart: my-app"))
        .stdout(predicates::str::contains("version: '2'"))
        .stdout(predicates::str::contains("replicas: 3"))
        .stdout(predicates::str::contains("tag: latest"));
}

#[test]
fn flux_plugin_re_exports() {
    let dir = tempfile::tempdir().unwrap();
    let root = dir.path();

    install_flux_plugin(root);

    // Import GitRepository from "fluxcd" (re-exported) instead of "fluxcd/source"
    let entry = root.join("entry.ts");
    std::fs::write(
        &entry,
        r#"
import { build, name } from "husako";
import { GitRepository } from "fluxcd";

const repo = GitRepository("my-repo")
    .url("https://github.com/example/repo")
    .ref({ tag: "v1.0.0" })
    .interval("5m");

build([repo]);
"#,
    )
    .unwrap();

    husako_at(root)
        .args(["render", entry.to_str().unwrap()])
        .assert()
        .success()
        .stdout(predicates::str::contains(
            "apiVersion: source.toolkit.fluxcd.io/v1",
        ))
        .stdout(predicates::str::contains("kind: GitRepository"))
        .stdout(predicates::str::contains("name: my-repo"))
        .stdout(predicates::str::contains("tag: v1.0.0"));
}

// --- husako add error cases ---

#[test]
fn add_no_args_errors() {
    let dir = tempfile::tempdir().unwrap();
    let root = dir.path();
    std::fs::write(root.join("husako.toml"), "[resources]\n").unwrap();

    husako_at(root).args(["add"]).assert().failure().code(2);
}

#[test]
fn add_registry_missing_name_errors() {
    let dir = tempfile::tempdir().unwrap();
    let root = dir.path();
    std::fs::write(root.join("husako.toml"), "[charts]\n").unwrap();

    husako_at(root)
        .args(["add", "https://charts.jetstack.io"])
        .assert()
        .failure()
        .code(2);
}

#[test]
fn add_unrecognized_url_errors() {
    let dir = tempfile::tempdir().unwrap();
    let root = dir.path();
    std::fs::write(root.join("husako.toml"), "[resources]\n").unwrap();

    husako_at(root)
        .args(["add", "foo_unknown_bar"])
        .assert()
        .failure()
        .code(2);
}

// --- husako add --cluster ---

#[test]
fn add_cluster_shows_server_url_from_config() {
    let dir = tempfile::tempdir().unwrap();
    let root = dir.path();
    std::fs::write(
        root.join("husako.toml"),
        "[cluster]\nserver = \"https://localhost:6443\"\n[resources]\n",
    )
    .unwrap();

    husako_at(root)
        .args(["add", "--cluster", "--yes"])
        .assert()
        .success()
        .stderr(predicates::str::contains("Cluster:"))
        .stderr(predicates::str::contains("default"))
        .stderr(predicates::str::contains("https://localhost:6443"));
}

#[test]
fn add_cluster_named_shows_server_url() {
    let dir = tempfile::tempdir().unwrap();
    let root = dir.path();
    std::fs::write(
        root.join("husako.toml"),
        "[clusters.dev]\nserver = \"https://dev:6443\"\n[resources]\n",
    )
    .unwrap();

    husako_at(root)
        .args(["add", "--cluster", "dev", "--yes"])
        .assert()
        .success()
        .stderr(predicates::str::contains("Cluster:"))
        .stderr(predicates::str::contains("dev"))
        .stderr(predicates::str::contains("https://dev:6443"));
}

#[test]
fn add_cluster_not_configured_fails() {
    // No [cluster] in husako.toml; HOME overridden so ~/.kube/ is empty,
    // preventing a real local kubeconfig from unexpectedly providing a server URL.
    let dir = tempfile::tempdir().unwrap();
    let root = dir.path();
    std::fs::write(root.join("husako.toml"), "[resources]\n").unwrap();

    husako_at(root)
        .args(["add", "--cluster"])
        .env("HOME", dir.path())
        .assert()
        .failure()
        .code(2)
        .stderr(predicates::str::contains("not configured"));
}

const KUBECONFIG_WITH_CURRENT_CONTEXT: &str = r#"
apiVersion: v1
kind: Config
current-context: my-ctx
clusters:
  - name: my-cluster
    cluster:
      server: https://k8s.local:6443
contexts:
  - name: my-ctx
    context:
      cluster: my-cluster
      user: my-user
users:
  - name: my-user
    user:
      token: tok
"#;

const KUBECONFIG_WITH_DEV_CONTEXT: &str = r#"
apiVersion: v1
kind: Config
current-context: dev
clusters:
  - name: dev-cluster
    cluster:
      server: https://dev:6443
contexts:
  - name: dev
    context:
      cluster: dev-cluster
      user: dev-user
users:
  - name: dev-user
    user:
      token: tok
"#;

#[test]
fn add_cluster_writes_cluster_config_from_kubeconfig() {
    let dir = tempfile::tempdir().unwrap();
    let root = dir.path();
    std::fs::write(root.join("husako.toml"), "[resources]\n").unwrap();
    let kube_dir = dir.path().join(".kube");
    std::fs::create_dir_all(&kube_dir).unwrap();
    std::fs::write(kube_dir.join("config"), KUBECONFIG_WITH_CURRENT_CONTEXT).unwrap();

    husako_at(root)
        .args(["add", "--cluster", "--yes"])
        .env("HOME", dir.path())
        .assert()
        .success()
        .stderr(predicates::str::contains("will add [cluster]"))
        .stderr(predicates::str::contains("Added [cluster] to husako.toml"));

    let content = std::fs::read_to_string(root.join("husako.toml")).unwrap();
    assert!(content.contains("[cluster]"));
    assert!(content.contains("https://k8s.local:6443"));
}

#[test]
fn add_cluster_named_writes_clusters_section_from_kubeconfig() {
    let dir = tempfile::tempdir().unwrap();
    let root = dir.path();
    std::fs::write(root.join("husako.toml"), "[resources]\n").unwrap();
    let kube_dir = dir.path().join(".kube");
    std::fs::create_dir_all(&kube_dir).unwrap();
    std::fs::write(kube_dir.join("config"), KUBECONFIG_WITH_DEV_CONTEXT).unwrap();

    husako_at(root)
        .args(["add", "--cluster", "dev", "--yes"])
        .env("HOME", dir.path())
        .assert()
        .success()
        .stderr(predicates::str::contains("will add [clusters.dev]"))
        .stderr(predicates::str::contains(
            "Added [clusters.dev] to husako.toml",
        ));

    let content = std::fs::read_to_string(root.join("husako.toml")).unwrap();
    assert!(content.contains("https://dev:6443"));
}
