use std::io::Write;
use std::path::Path;

use assert_cmd::cargo::cargo_bin_cmd;
use tempfile::NamedTempFile;

fn husako() -> assert_cmd::Command {
    cargo_bin_cmd!("husako")
}

fn husako_at(dir: &std::path::Path) -> assert_cmd::Command {
    let mut cmd = cargo_bin_cmd!("husako");
    cmd.current_dir(dir);
    cmd
}

fn write_temp_ts(content: &str) -> NamedTempFile {
    let mut f = tempfile::Builder::new().suffix(".ts").tempfile().unwrap();
    f.write_all(content.as_bytes()).unwrap();
    f
}

/// Write generated k8s runtime JS modules into `.husako/types/k8s/` under `root`.
fn write_k8s_modules(root: &Path) {
    let apps_dir = root.join(".husako/types/k8s/apps");
    std::fs::create_dir_all(&apps_dir).unwrap();
    std::fs::write(
        apps_dir.join("v1.js"),
        r#"// Auto-generated by husako. Do not edit.

import { _ResourceBuilder } from "husako/_base";

class _Deployment extends _ResourceBuilder {
  constructor() { super("apps/v1", "Deployment"); }
  replicas(v) { return this._setSpec("replicas", v); }
  selector(v) { return this._setSpec("selector", v); }
  strategy(v) { return this._setSpec("strategy", v); }
  template(v) { return this._setSpec("template", v); }
  containers(v) { return this._setDeep("template.spec.containers", v); }
  initContainers(v) { return this._setDeep("template.spec.initContainers", v); }
}
export function Deployment() { return new _Deployment(); }

class _StatefulSet extends _ResourceBuilder {
  constructor() { super("apps/v1", "StatefulSet"); }
  replicas(v) { return this._setSpec("replicas", v); }
  selector(v) { return this._setSpec("selector", v); }
  template(v) { return this._setSpec("template", v); }
  containers(v) { return this._setDeep("template.spec.containers", v); }
  initContainers(v) { return this._setDeep("template.spec.initContainers", v); }
}
export function StatefulSet() { return new _StatefulSet(); }

class _DaemonSet extends _ResourceBuilder {
  constructor() { super("apps/v1", "DaemonSet"); }
  selector(v) { return this._setSpec("selector", v); }
  template(v) { return this._setSpec("template", v); }
  containers(v) { return this._setDeep("template.spec.containers", v); }
  initContainers(v) { return this._setDeep("template.spec.initContainers", v); }
}
export function DaemonSet() { return new _DaemonSet(); }
"#,
    )
    .unwrap();

    let core_dir = root.join(".husako/types/k8s/core");
    std::fs::create_dir_all(&core_dir).unwrap();
    std::fs::write(
        core_dir.join("v1.js"),
        r#"// Auto-generated by husako. Do not edit.

import { _ResourceBuilder, _SchemaBuilder } from "husako/_base";

class _Namespace extends _ResourceBuilder {
  constructor() { super("v1", "Namespace"); }
}
export function Namespace() { return new _Namespace(); }

class _Service extends _ResourceBuilder {
  constructor() { super("v1", "Service"); }
  selector(v) { return this._setSpec("selector", v); }
  ports(v) { return this._setSpec("ports", v); }
  type(v) { return this._setSpec("type", v); }
}
export function Service() { return new _Service(); }

class _ConfigMap extends _ResourceBuilder {
  constructor() { super("v1", "ConfigMap"); }
  data(v) { return this.set("data", v); }
  binaryData(v) { return this.set("binaryData", v); }
  immutable(v) { return this.set("immutable", v); }
}
export function ConfigMap() { return new _ConfigMap(); }

class _Container extends _SchemaBuilder {
  name(v) { return this._set("name", v); }
  image(v) { return this._set("image", v); }
  ports(v) { return this._set("ports", v); }
  resources(v) { return this._set("resources", v); }
  env(v) { return this._set("env", v); }
  command(v) { return this._set("command", v); }
  args(v) { return this._set("args", v); }
  volumeMounts(v) { return this._set("volumeMounts", v); }
}
export function Container() { return new _Container(); }

class _PodTemplateSpec extends _SchemaBuilder {
  metadata(v) { return this._set("metadata", v); }
  spec(v) { return this._set("spec", v); }
}
export function PodTemplateSpec() { return new _PodTemplateSpec(); }
export function PodTemplate() { return new _PodTemplateSpec(); }
"#,
    )
    .unwrap();

    // _common.js for common schema builders (LabelSelector, etc.)
    let common_dir = root.join(".husako/types/k8s");
    std::fs::write(
        common_dir.join("_common.js"),
        r#"// Auto-generated by husako. Do not edit.

import { _SchemaBuilder } from "husako/_base";

class _LabelSelector extends _SchemaBuilder {
  matchLabels(v) { return this._set("matchLabels", v); }
  matchExpressions(v) { return this._set("matchExpressions", v); }
}
export function LabelSelector() { return new _LabelSelector(); }
"#,
    )
    .unwrap();
}

/// Create a temp project dir with k8s modules, write the given TS content as entry.ts,
/// and return (tempdir, entry_path).
fn project_with_k8s(ts_content: &str) -> (tempfile::TempDir, std::path::PathBuf) {
    let dir = tempfile::tempdir().unwrap();
    let root = dir.path();
    write_k8s_modules(root);

    let entry = root.join("entry.ts");
    std::fs::write(&entry, ts_content).unwrap();
    (dir, entry)
}

#[test]
fn version_subcommand() {
    husako()
        .arg("version")
        .assert()
        .success()
        .stderr(predicates::str::contains("husako "));
}

#[test]
fn missing_build() {
    let f = write_temp_ts(r#"import { build } from "husako"; const x = 1;"#);
    husako()
        .args(["render", f.path().to_str().unwrap()])
        .assert()
        .code(7)
        .stderr(predicates::str::contains("build() was not called"));
}

#[test]
fn double_build() {
    let f = write_temp_ts(r#"import { build } from "husako"; build([]); build([]);"#);
    husako()
        .args(["render", f.path().to_str().unwrap()])
        .assert()
        .code(7)
        .stderr(predicates::str::contains("called 2 times"));
}

#[test]
fn strict_json_undefined() {
    let f = write_temp_ts(
        r#"import { build } from "husako"; build({ _render() { return { a: undefined }; } });"#,
    );
    husako()
        .args(["render", f.path().to_str().unwrap()])
        .assert()
        .code(7)
        .stderr(predicates::str::contains("undefined"));
}

#[test]
fn strict_json_function() {
    let f = write_temp_ts(
        r#"import { build } from "husako"; build({ _render() { return { fn: () => {} }; } });"#,
    );
    husako()
        .args(["render", f.path().to_str().unwrap()])
        .assert()
        .code(7)
        .stderr(predicates::str::contains("function"));
}

#[test]
fn compile_error() {
    let f = write_temp_ts("const = ;");
    husako()
        .args(["render", f.path().to_str().unwrap()])
        .assert()
        .code(3);
}

// --- Milestone 2: Module Loader + Project Imports ---

#[test]
fn render_project_imports() {
    let dir = tempfile::tempdir().unwrap();
    let root = dir.path();
    write_k8s_modules(root);

    // Replicate examples/project/ structure with builders
    std::fs::create_dir_all(root.join("lib")).unwrap();
    std::fs::write(
        root.join("lib/metadata.ts"),
        r#"import { metadata } from "husako";
export function appMetadata(appName: string) {
  return metadata().name(appName).label("app", appName);
}
"#,
    )
    .unwrap();
    std::fs::write(
        root.join("lib/index.ts"),
        r#"export { appMetadata } from "./metadata";"#,
    )
    .unwrap();

    std::fs::create_dir_all(root.join("deployments")).unwrap();
    std::fs::write(
        root.join("deployments/nginx.ts"),
        r#"import { Deployment } from "k8s/apps/v1";
import { Container } from "k8s/core/v1";
import { LabelSelector } from "k8s/_common";
import { appMetadata } from "../lib";
export const nginx = Deployment()
  .metadata(appMetadata("nginx"))
  .replicas(1)
  .selector(LabelSelector().matchLabels({ app: "nginx" }))
  .containers([Container().name("nginx").image("nginx:1.25")]);
"#,
    )
    .unwrap();

    std::fs::create_dir_all(root.join("env")).unwrap();
    let entry = root.join("env/dev.ts");
    std::fs::write(
        &entry,
        r#"import { build } from "husako";
import { nginx } from "../deployments/nginx";
build([nginx]);
"#,
    )
    .unwrap();

    husako_at(root)
        .args(["render", entry.to_str().unwrap()])
        .assert()
        .success()
        .stdout(predicates::str::contains("apiVersion: apps/v1"))
        .stdout(predicates::str::contains("kind: Deployment"))
        .stdout(predicates::str::contains("name: nginx"))
        .stdout(predicates::str::contains("app: nginx"));
}

#[test]
fn render_project_snapshot() {
    let dir = tempfile::tempdir().unwrap();
    let root = dir.path();
    write_k8s_modules(root);

    std::fs::create_dir_all(root.join("lib")).unwrap();
    std::fs::write(
        root.join("lib/metadata.ts"),
        r#"import { metadata } from "husako";
export function appMetadata(appName: string) {
  return metadata().name(appName).label("app", appName);
}
"#,
    )
    .unwrap();
    std::fs::write(
        root.join("lib/index.ts"),
        r#"export { appMetadata } from "./metadata";"#,
    )
    .unwrap();

    std::fs::create_dir_all(root.join("deployments")).unwrap();
    std::fs::write(
        root.join("deployments/nginx.ts"),
        r#"import { Deployment } from "k8s/apps/v1";
import { Container } from "k8s/core/v1";
import { LabelSelector } from "k8s/_common";
import { appMetadata } from "../lib";
export const nginx = Deployment()
  .metadata(appMetadata("nginx"))
  .replicas(1)
  .selector(LabelSelector().matchLabels({ app: "nginx" }))
  .containers([Container().name("nginx").image("nginx:1.25")]);
"#,
    )
    .unwrap();

    std::fs::create_dir_all(root.join("env")).unwrap();
    let entry = root.join("env/dev.ts");
    std::fs::write(
        &entry,
        r#"import { build } from "husako";
import { nginx } from "../deployments/nginx";
build([nginx]);
"#,
    )
    .unwrap();

    let output = husako_at(root)
        .args(["render", entry.to_str().unwrap()])
        .output()
        .unwrap();
    assert!(output.status.success());
    let yaml = String::from_utf8(output.stdout).unwrap();
    insta::assert_snapshot!(yaml);
}

#[test]
fn reject_outside_root() {
    let dir = tempfile::tempdir().unwrap();
    let root = dir.path();
    let sub = root.join("sub");
    std::fs::create_dir(&sub).unwrap();

    // Create a file outside the sub directory
    std::fs::write(root.join("secret.ts"), "export const x = 1;").unwrap();

    // Create entry file that imports outside root
    let entry = sub.join("entry.ts");
    std::fs::write(
        &entry,
        r#"import { build } from "husako"; import { x } from "../secret"; build([{ _render() { return { v: x }; } }]);"#,
    )
    .unwrap();

    // Run with cwd=sub so project_root=sub
    husako_at(&sub)
        .args(["render", entry.to_str().unwrap()])
        .assert()
        .code(4)
        .stderr(predicates::str::contains("outside project root"));
}

#[test]
fn allow_outside_root_flag() {
    let dir = tempfile::tempdir().unwrap();
    let root = dir.path();
    let sub = root.join("sub");
    std::fs::create_dir(&sub).unwrap();

    std::fs::write(root.join("outside.ts"), "export const val = 42;").unwrap();

    let entry = sub.join("entry.ts");
    std::fs::write(
        &entry,
        r#"import { build } from "husako"; import { val } from "../outside"; build([{ _render() { return { v: val }; } }]);"#,
    )
    .unwrap();

    // With --allow-outside-root, the boundary check is bypassed
    husako_at(&sub)
        .args(["render", "--allow-outside-root", entry.to_str().unwrap()])
        .assert()
        .success()
        .stdout(predicates::str::contains("v: 42"));
}

#[test]
fn extension_inference() {
    let dir = tempfile::tempdir().unwrap();
    let root = dir.path();

    // import "./lib" should resolve to lib.ts
    std::fs::write(root.join("lib.ts"), "export const x: number = 1;").unwrap();
    let entry = root.join("entry.ts");
    std::fs::write(
        &entry,
        r#"import { build } from "husako"; import { x } from "./lib"; build([{ _render() { return { v: x }; } }]);"#,
    )
    .unwrap();

    husako_at(root)
        .args(["render", entry.to_str().unwrap()])
        .assert()
        .success()
        .stdout(predicates::str::contains("v: 1"));
}

// --- Milestone 3: SDK Builders (now using generated k8s modules) ---

#[test]
fn render_canonical() {
    let (dir, entry) = project_with_k8s(
        r#"
import * as husako from "husako";
import { Deployment } from "k8s/apps/v1";
import { name, namespace, label, cpu, memory, requests, limits } from "husako";

const nginx_metadata = name("nginx")
  .namespace("nginx-ns")
  .label("key1", "value1")
  .label("key2", "value2");

const another_labels_1 = label("key3", "value3").label("key4", "value4");
const another_labels_2 = label("key5", "value5").label("key6", "value6");

const nginx = Deployment()
  .metadata(husako.merge([nginx_metadata, another_labels_1, another_labels_2]))
  .resources(
    requests(cpu(1).memory("2Gi")).limits(cpu("500m").memory(1))
  );

husako.build([nginx]);
"#,
    );
    husako_at(dir.path())
        .args(["render", entry.to_str().unwrap()])
        .assert()
        .success()
        .stdout(predicates::str::contains("apiVersion: apps/v1"))
        .stdout(predicates::str::contains("kind: Deployment"))
        .stdout(predicates::str::contains("name: nginx"))
        .stdout(predicates::str::contains("namespace: nginx-ns"))
        .stdout(predicates::str::contains("key1: value1"))
        .stdout(predicates::str::contains("key5: value5"))
        .stdout(predicates::str::contains("cpu: '1'"))
        .stdout(predicates::str::contains("memory: 2Gi"))
        .stdout(predicates::str::contains("cpu: 500m"))
        .stdout(predicates::str::contains("memory: 1Gi"));
}

#[test]
fn render_canonical_snapshot() {
    let (dir, entry) = project_with_k8s(
        r#"
import * as husako from "husako";
import { Deployment } from "k8s/apps/v1";
import { name, namespace, label, cpu, memory, requests, limits } from "husako";

const nginx_metadata = name("nginx")
  .namespace("nginx-ns")
  .label("key1", "value1")
  .label("key2", "value2");

const another_labels_1 = label("key3", "value3").label("key4", "value4");
const another_labels_2 = label("key5", "value5").label("key6", "value6");

const nginx = Deployment()
  .metadata(husako.merge([nginx_metadata, another_labels_1, another_labels_2]))
  .resources(
    requests(cpu(1).memory("2Gi")).limits(cpu("500m").memory(1))
  );

husako.build([nginx]);
"#,
    );
    let output = husako_at(dir.path())
        .args(["render", entry.to_str().unwrap()])
        .output()
        .unwrap();
    assert!(output.status.success());
    let yaml = String::from_utf8(output.stdout).unwrap();
    insta::assert_snapshot!(yaml);
}

#[test]
fn metadata_fragment_reuse() {
    let (dir, entry) = project_with_k8s(
        r#"
import { build, label } from "husako";
import { Deployment } from "k8s/apps/v1";
const base = label("env", "dev");
const a = base.label("team", "a");
const b = base.label("team", "b");
const da = Deployment().metadata(a);
const db = Deployment().metadata(b);
build([da, db]);
"#,
    );
    let output = husako_at(dir.path())
        .args(["render", entry.to_str().unwrap()])
        .output()
        .unwrap();
    assert!(output.status.success());
    let yaml = String::from_utf8(output.stdout).unwrap();
    // Both should have env: dev
    assert_eq!(yaml.matches("env: dev").count(), 2);
    // a should have team: a, b should have team: b
    assert!(yaml.contains("team: a"));
    assert!(yaml.contains("team: b"));
}

#[test]
fn merge_labels_deep() {
    let (dir, entry) = project_with_k8s(
        r#"
import { build, name, label, merge } from "husako";
import { Deployment } from "k8s/apps/v1";
const m = merge([name("test"), label("a", "1"), label("b", "2"), label("c", "3")]);
const d = Deployment().metadata(m);
build([d]);
"#,
    );
    husako_at(dir.path())
        .args(["render", entry.to_str().unwrap()])
        .assert()
        .success()
        .stdout(predicates::str::contains("name: test"))
        .stdout(predicates::str::contains("a: '1'"))
        .stdout(predicates::str::contains("b: '2'"))
        .stdout(predicates::str::contains("c: '3'"));
}

#[test]
fn cpu_normalization() {
    let (dir, entry) = project_with_k8s(
        r#"
import { build, cpu, requests } from "husako";
import { Deployment } from "k8s/apps/v1";
const d = Deployment().resources(requests(cpu(0.5)));
build([d]);
"#,
    );
    husako_at(dir.path())
        .args(["render", entry.to_str().unwrap()])
        .assert()
        .success()
        .stdout(predicates::str::contains("cpu: 500m"));
}

#[test]
fn memory_normalization() {
    let (dir, entry) = project_with_k8s(
        r#"
import { build, memory, requests } from "husako";
import { Deployment } from "k8s/apps/v1";
const d = Deployment().resources(requests(memory(4)));
build([d]);
"#,
    );
    husako_at(dir.path())
        .args(["render", entry.to_str().unwrap()])
        .assert()
        .success()
        .stdout(predicates::str::contains("memory: 4Gi"));
}

#[test]
fn k8s_core_v1_namespace() {
    let (dir, entry) = project_with_k8s(
        r#"
import { build, name } from "husako";
import { Namespace } from "k8s/core/v1";
const ns = Namespace().metadata(name("my-ns"));
build([ns]);
"#,
    );
    husako_at(dir.path())
        .args(["render", entry.to_str().unwrap()])
        .assert()
        .success()
        .stdout(predicates::str::contains("apiVersion: v1"))
        .stdout(predicates::str::contains("kind: Namespace"))
        .stdout(predicates::str::contains("name: my-ns"));
}

#[test]
fn index_inference() {
    let dir = tempfile::tempdir().unwrap();
    let root = dir.path();

    // import "./lib" should resolve to lib/index.ts
    let lib = root.join("lib");
    std::fs::create_dir(&lib).unwrap();
    std::fs::write(lib.join("index.ts"), "export const x: number = 99;").unwrap();

    let entry = root.join("entry.ts");
    std::fs::write(
        &entry,
        r#"import { build } from "husako"; import { x } from "./lib"; build([{ _render() { return { v: x }; } }]);"#,
    )
    .unwrap();

    husako_at(root)
        .args(["render", entry.to_str().unwrap()])
        .assert()
        .success()
        .stdout(predicates::str::contains("v: 99"));
}

// --- Milestone 6: Schema-aware Quantity Validation ---

#[test]
fn invalid_quantity_fallback_exit_7() {
    let f = write_temp_ts(
        r#"
import { build } from "husako";
build([{ _render() { return {
    apiVersion: "apps/v1",
    kind: "Deployment",
    spec: {
        template: {
            spec: {
                containers: [{
                    resources: {
                        requests: { cpu: "2gb" }
                    }
                }]
            }
        }
    }
}; } }]);
"#,
    );
    husako()
        .args(["render", f.path().to_str().unwrap()])
        .assert()
        .code(7)
        .stderr(predicates::str::contains("invalid quantity"))
        .stderr(predicates::str::contains("2gb"));
}

#[test]
fn valid_quantities_exit_0() {
    let f = write_temp_ts(
        r#"
import { build } from "husako";
build([{ _render() { return {
    apiVersion: "apps/v1",
    kind: "Deployment",
    spec: {
        template: {
            spec: {
                containers: [{
                    resources: {
                        requests: { cpu: "500m", memory: "1Gi" },
                        limits: { cpu: "1", memory: "2Gi" }
                    }
                }]
            }
        }
    }
}; } }]);
"#,
    );
    husako()
        .args(["render", f.path().to_str().unwrap()])
        .assert()
        .success();
}

#[test]
fn numbers_at_quantity_positions_exit_0() {
    let f = write_temp_ts(
        r#"
import { build } from "husako";
build([{ _render() { return {
    apiVersion: "apps/v1",
    kind: "Deployment",
    spec: {
        template: {
            spec: {
                containers: [{
                    resources: {
                        requests: { cpu: 1, memory: 2 }
                    }
                }]
            }
        }
    }
}; } }]);
"#,
    );
    husako()
        .args(["render", f.path().to_str().unwrap()])
        .assert()
        .success();
}

// --- Milestone 5: Type Generation + husako generate ---

#[test]
fn generate_skip_k8s() {
    let dir = tempfile::tempdir().unwrap();
    let root = dir.path();

    husako_at(root)
        .args(["gen", "--skip-k8s"])
        .assert()
        .success();

    // Static .d.ts files should exist
    assert!(root.join(".husako/types/husako.d.ts").exists());
    assert!(root.join(".husako/types/husako/_base.d.ts").exists());

    // tsconfig.json should exist with husako paths
    let tsconfig = std::fs::read_to_string(root.join("tsconfig.json")).unwrap();
    let parsed: serde_json::Value = serde_json::from_str(&tsconfig).unwrap();
    assert!(parsed["compilerOptions"]["paths"]["husako"].is_array());
    assert!(parsed["compilerOptions"]["paths"]["k8s/*"].is_array());

    // No k8s/ directory since we skipped k8s types
    assert!(!root.join(".husako/types/k8s").exists());
}

fn write_mock_spec(dir: &Path, group_path: &str) {
    let spec = rich_mock_spec();
    let spec_path = dir.join(format!("{group_path}.json"));
    std::fs::create_dir_all(spec_path.parent().unwrap()).unwrap();
    std::fs::write(spec_path, spec.to_string()).unwrap();
}

fn rich_mock_spec() -> serde_json::Value {
    serde_json::json!({
        "components": {
            "schemas": {
                "io.k8s.api.apps.v1.Deployment": {
                    "description": "Deployment enables declarative updates.",
                    "properties": {
                        "apiVersion": {"type": "string"},
                        "kind": {"type": "string"},
                        "metadata": {"$ref": "#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"},
                        "spec": {"$ref": "#/components/schemas/io.k8s.api.apps.v1.DeploymentSpec"}
                    },
                    "x-kubernetes-group-version-kind": [
                        {"group": "apps", "version": "v1", "kind": "Deployment"}
                    ]
                },
                "io.k8s.api.apps.v1.DeploymentSpec": {
                    "properties": {
                        "replicas": {"type": "integer"},
                        "selector": {"$ref": "#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.LabelSelector"},
                        "strategy": {"$ref": "#/components/schemas/io.k8s.api.apps.v1.DeploymentStrategy"},
                        "template": {"$ref": "#/components/schemas/io.k8s.api.core.v1.PodTemplateSpec"}
                    },
                    "required": ["selector"]
                },
                "io.k8s.api.apps.v1.DeploymentStrategy": {
                    "properties": {
                        "type": {
                            "type": "string",
                            "enum": ["Recreate", "RollingUpdate"]
                        }
                    }
                },
                "io.k8s.api.core.v1.PodTemplateSpec": {
                    "properties": {
                        "spec": {"$ref": "#/components/schemas/io.k8s.api.core.v1.PodSpec"}
                    }
                },
                "io.k8s.api.core.v1.PodSpec": {
                    "properties": {
                        "containers": {
                            "type": "array",
                            "items": {"$ref": "#/components/schemas/io.k8s.api.core.v1.Container"}
                        }
                    }
                },
                "io.k8s.api.core.v1.Container": {
                    "properties": {
                        "name": {"type": "string"},
                        "imagePullPolicy": {
                            "type": "string",
                            "enum": ["Always", "IfNotPresent", "Never"]
                        },
                        "resources": {"$ref": "#/components/schemas/io.k8s.api.core.v1.ResourceRequirements"}
                    }
                },
                "io.k8s.api.core.v1.ResourceRequirements": {
                    "properties": {
                        "limits": {
                            "type": "object",
                            "additionalProperties": {"$ref": "#/components/schemas/io.k8s.apimachinery.pkg.api.resource.Quantity"}
                        },
                        "requests": {
                            "type": "object",
                            "additionalProperties": {"$ref": "#/components/schemas/io.k8s.apimachinery.pkg.api.resource.Quantity"}
                        }
                    }
                },
                "io.k8s.apimachinery.pkg.api.resource.Quantity": {
                    "description": "Quantity is a representation of a decimal number.",
                    "type": "string"
                },
                "io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta": {
                    "description": "Standard object metadata.",
                    "properties": {
                        "name": {"type": "string"},
                        "namespace": {"type": "string"}
                    }
                },
                "io.k8s.apimachinery.pkg.apis.meta.v1.LabelSelector": {
                    "properties": {
                        "matchLabels": {
                            "type": "object",
                            "additionalProperties": {"type": "string"}
                        }
                    }
                }
            }
        }
    })
}

/// Write a `_schema.json` at `.husako/types/k8s/_schema.json` using husako_dts.
fn write_schema_store(root: &Path) {
    let spec = rich_mock_spec();
    let specs = std::collections::HashMap::from([("apis/apps/v1".to_string(), spec)]);
    let store = husako_dts::schema_store::generate_schema_store(&specs);
    let json = serde_json::to_string_pretty(&store).unwrap();
    let schema_dir = root.join(".husako/types/k8s");
    std::fs::create_dir_all(&schema_dir).unwrap();
    std::fs::write(schema_dir.join("_schema.json"), json).unwrap();
}

#[test]
fn generate_spec_dir() {
    let dir = tempfile::tempdir().unwrap();
    let root = dir.path();

    // Create mock spec directory
    let spec_dir = root.join("specs");
    std::fs::create_dir_all(&spec_dir).unwrap();
    write_mock_spec(&spec_dir, "apis/apps/v1");

    husako_at(root)
        .args(["gen", "--spec-dir", spec_dir.to_str().unwrap()])
        .assert()
        .success();

    // Static .d.ts files should exist
    assert!(root.join(".husako/types/husako.d.ts").exists());
    assert!(root.join(".husako/types/husako/_base.d.ts").exists());

    // Generated k8s types should exist (.d.ts and .js)
    assert!(root.join(".husako/types/k8s/_common.d.ts").exists());
    assert!(root.join(".husako/types/k8s/apps/v1.d.ts").exists());
    assert!(root.join(".husako/types/k8s/apps/v1.js").exists());

    // .d.ts should contain Deployment builder (interface + factory)
    let apps_v1 = std::fs::read_to_string(root.join(".husako/types/k8s/apps/v1.d.ts")).unwrap();
    assert!(apps_v1.contains("interface Deployment"));
    assert!(apps_v1.contains("_ResourceBuilder"));

    // .js should contain internal class + factory function
    let apps_v1_js = std::fs::read_to_string(root.join(".husako/types/k8s/apps/v1.js")).unwrap();
    assert!(apps_v1_js.contains("class _Deployment"));
    assert!(apps_v1_js.contains("\"apps/v1\""));

    // tsconfig.json should exist
    assert!(root.join("tsconfig.json").exists());
}

#[test]
fn generate_updates_existing_tsconfig() {
    let dir = tempfile::tempdir().unwrap();
    let root = dir.path();

    // Pre-create tsconfig.json with existing content
    let existing = serde_json::json!({
        "compilerOptions": {
            "strict": true,
            "target": "ES2020",
            "paths": {
                "mylib/*": ["./lib/*"]
            }
        },
        "include": ["src/**/*"]
    });
    std::fs::write(
        root.join("tsconfig.json"),
        serde_json::to_string_pretty(&existing).unwrap(),
    )
    .unwrap();

    husako_at(root)
        .args(["gen", "--skip-k8s"])
        .assert()
        .success();

    let tsconfig = std::fs::read_to_string(root.join("tsconfig.json")).unwrap();
    let parsed: serde_json::Value = serde_json::from_str(&tsconfig).unwrap();

    // Original fields preserved
    assert_eq!(parsed["compilerOptions"]["target"], "ES2020");
    assert!(parsed["include"].is_array());

    // Original path preserved
    assert!(parsed["compilerOptions"]["paths"]["mylib/*"].is_array());

    // husako paths added
    assert!(parsed["compilerOptions"]["paths"]["husako"].is_array());
    assert!(parsed["compilerOptions"]["paths"]["husako/_base"].is_array());
    assert!(parsed["compilerOptions"]["paths"]["k8s/*"].is_array());
}

// --- Milestone 7: Schema-based Validation ---

#[test]
fn schema_invalid_enum_exit_7() {
    let dir = tempfile::tempdir().unwrap();
    let root = dir.path();
    write_schema_store(root);

    let entry = root.join("entry.ts");
    std::fs::write(
        &entry,
        r#"
import { build } from "husako";
build([{ _render() { return {
    apiVersion: "apps/v1",
    kind: "Deployment",
    spec: {
        selector: {},
        strategy: { type: "bluegreen" }
    }
}; } }]);
"#,
    )
    .unwrap();

    husako_at(root)
        .args(["render", entry.to_str().unwrap()])
        .assert()
        .code(7)
        .stderr(predicates::str::contains("invalid value"))
        .stderr(predicates::str::contains("bluegreen"));
}

#[test]
fn schema_type_mismatch_exit_7() {
    let dir = tempfile::tempdir().unwrap();
    let root = dir.path();
    write_schema_store(root);

    let entry = root.join("entry.ts");
    std::fs::write(
        &entry,
        r#"
import { build } from "husako";
build([{ _render() { return {
    apiVersion: "apps/v1",
    kind: "Deployment",
    spec: {
        selector: {},
        replicas: "abc"
    }
}; } }]);
"#,
    )
    .unwrap();

    husako_at(root)
        .args(["render", entry.to_str().unwrap()])
        .assert()
        .code(7)
        .stderr(predicates::str::contains("expected type integer"));
}

#[test]
fn schema_missing_required_exit_7() {
    let dir = tempfile::tempdir().unwrap();
    let root = dir.path();
    write_schema_store(root);

    let entry = root.join("entry.ts");
    std::fs::write(
        &entry,
        r#"
import { build } from "husako";
build([{ _render() { return {
    apiVersion: "apps/v1",
    kind: "Deployment",
    spec: {
        replicas: 3
    }
}; } }]);
"#,
    )
    .unwrap();

    husako_at(root)
        .args(["render", entry.to_str().unwrap()])
        .assert()
        .code(7)
        .stderr(predicates::str::contains("missing required field"));
}

#[test]
fn schema_valid_passes() {
    let dir = tempfile::tempdir().unwrap();
    let root = dir.path();
    write_schema_store(root);

    let entry = root.join("entry.ts");
    std::fs::write(
        &entry,
        r#"
import { build } from "husako";
build([{ _render() { return {
    apiVersion: "apps/v1",
    kind: "Deployment",
    spec: {
        selector: { matchLabels: { app: "test" } },
        replicas: 3,
        strategy: { type: "RollingUpdate" },
        template: {
            spec: {
                containers: [{
                    name: "main",
                    imagePullPolicy: "Always",
                    resources: {
                        requests: { cpu: "500m", memory: "1Gi" },
                        limits: { cpu: "1", memory: "2Gi" }
                    }
                }]
            }
        }
    }
}; } }]);
"#,
    )
    .unwrap();

    husako_at(root)
        .args(["render", entry.to_str().unwrap()])
        .assert()
        .success();
}

#[test]
fn schema_invalid_quantity_exit_7() {
    let dir = tempfile::tempdir().unwrap();
    let root = dir.path();
    write_schema_store(root);

    let entry = root.join("entry.ts");
    std::fs::write(
        &entry,
        r#"
import { build } from "husako";
build([{ _render() { return {
    apiVersion: "apps/v1",
    kind: "Deployment",
    spec: {
        selector: {},
        template: {
            spec: {
                containers: [{
                    resources: {
                        requests: { cpu: "2gb" }
                    }
                }]
            }
        }
    }
}; } }]);
"#,
    )
    .unwrap();

    husako_at(root)
        .args(["render", entry.to_str().unwrap()])
        .assert()
        .code(7)
        .stderr(predicates::str::contains("invalid quantity"))
        .stderr(predicates::str::contains("2gb"));
}

// --- Milestone 8: Safety & Diagnostics ---

#[test]
fn timeout_infinite_loop_exit_4() {
    let f = write_temp_ts(
        r#"
import { build } from "husako";
while(true) {}
build([]);
"#,
    );
    husako()
        .args(["render", "--timeout-ms", "100", f.path().to_str().unwrap()])
        .assert()
        .code(4)
        .stderr(predicates::str::contains("timed out"));
}

#[test]
fn memory_limit_exit_4() {
    let f = write_temp_ts(
        r#"
import { build } from "husako";
const arr = [];
for (let i = 0; i < 10000000; i++) { arr.push(new Array(1000)); }
build([]);
"#,
    );
    husako()
        .args(["render", "--max-heap-mb", "1", f.path().to_str().unwrap()])
        .assert()
        .code(4)
        .stderr(predicates::str::contains("memory limit"));
}

#[test]
fn timeout_does_not_interfere_with_normal_script() {
    let f = write_temp_ts(
        r#"
import { build } from "husako";
build([{ _render() { return { apiVersion: "v1", kind: "Namespace", metadata: { name: "test" } }; } }]);
"#,
    );
    husako()
        .args(["render", "--timeout-ms", "5000", f.path().to_str().unwrap()])
        .assert()
        .success()
        .stdout(predicates::str::contains("kind: Namespace"));
}

#[test]
fn verbose_produces_stderr_output() {
    let f = write_temp_ts(
        r#"
import { build } from "husako";
build([{ _render() { return { apiVersion: "v1", kind: "Namespace", metadata: { name: "test" } }; } }]);
"#,
    );
    husako()
        .args(["render", "--verbose", f.path().to_str().unwrap()])
        .assert()
        .success()
        .stderr(predicates::str::contains("[compile]"))
        .stderr(predicates::str::contains("[execute]"))
        .stderr(predicates::str::contains("[validate]"))
        .stderr(predicates::str::contains("[emit]"));
}

#[test]
fn generate_creates_schema_json() {
    let dir = tempfile::tempdir().unwrap();
    let root = dir.path();

    let spec_dir = root.join("specs");
    std::fs::create_dir_all(&spec_dir).unwrap();
    write_mock_spec(&spec_dir, "apis/apps/v1");

    husako_at(root)
        .args(["gen", "--spec-dir", spec_dir.to_str().unwrap()])
        .assert()
        .success();

    // _schema.json should exist (replaces _validation.json)
    assert!(root.join(".husako/types/k8s/_schema.json").exists());

    // Check basic structure
    let content = std::fs::read_to_string(root.join(".husako/types/k8s/_schema.json")).unwrap();
    let parsed: serde_json::Value = serde_json::from_str(&content).unwrap();
    assert_eq!(parsed["version"], 2);
    assert!(parsed["gvk_index"].is_object());
    assert!(parsed["schemas"].is_object());
}

// --- husako new ---

#[test]
fn new_simple_creates_project() {
    let dir = tempfile::tempdir().unwrap();
    let target = dir.path().join("my-app");

    husako()
        .args(["new", target.to_str().unwrap()])
        .assert()
        .success()
        .stderr(predicates::str::contains("Created 'simple' project"))
        .stderr(predicates::str::contains("kubernetes"))
        .stderr(predicates::str::contains("husako gen"));

    assert!(target.join(".gitignore").exists());
    assert!(target.join("husako.toml").exists());
    assert!(target.join("entry.ts").exists());
}

#[test]
fn new_project_template() {
    let dir = tempfile::tempdir().unwrap();
    let target = dir.path().join("my-app");

    husako()
        .args(["new", "--template", "project", target.to_str().unwrap()])
        .assert()
        .success()
        .stderr(predicates::str::contains("Created 'project' project"))
        .stderr(predicates::str::contains("kubernetes"));

    assert!(target.join(".gitignore").exists());
    assert!(target.join("husako.toml").exists());
    assert!(target.join("env/dev.ts").exists());
    assert!(target.join("deployments/nginx.ts").exists());
    assert!(target.join("lib/index.ts").exists());
    assert!(target.join("lib/metadata.ts").exists());
}

#[test]
fn new_multi_env_template() {
    let dir = tempfile::tempdir().unwrap();
    let target = dir.path().join("my-app");

    husako()
        .args(["new", "--template", "multi-env", target.to_str().unwrap()])
        .assert()
        .success()
        .stderr(predicates::str::contains("Created 'multi-env' project"))
        .stderr(predicates::str::contains("kubernetes"));

    assert!(target.join(".gitignore").exists());
    assert!(target.join("husako.toml").exists());
    assert!(target.join("base/nginx.ts").exists());
    assert!(target.join("base/service.ts").exists());
    assert!(target.join("dev/main.ts").exists());
    assert!(target.join("staging/main.ts").exists());
    assert!(target.join("release/main.ts").exists());
}

#[test]
fn new_rejects_nonempty_dir() {
    let dir = tempfile::tempdir().unwrap();
    let target = dir.path().join("my-app");
    std::fs::create_dir_all(&target).unwrap();
    std::fs::write(target.join("existing.txt"), "content").unwrap();

    husako()
        .args(["new", target.to_str().unwrap()])
        .assert()
        .code(1)
        .stderr(predicates::str::contains("not empty"));
}

#[test]
fn new_then_render_simple() {
    let dir = tempfile::tempdir().unwrap();
    let target = dir.path().join("my-app");

    // Scaffold
    husako()
        .args(["new", target.to_str().unwrap()])
        .assert()
        .success();

    // Write k8s modules for rendering
    write_k8s_modules(&target);

    // Render
    husako_at(&target)
        .args(["render", target.join("entry.ts").to_str().unwrap()])
        .assert()
        .success()
        .stdout(predicates::str::contains("apiVersion: apps/v1"))
        .stdout(predicates::str::contains("kind: Deployment"))
        .stdout(predicates::str::contains("name: nginx"));
}

#[test]
fn new_then_render_project() {
    let dir = tempfile::tempdir().unwrap();
    let target = dir.path().join("my-app");

    // Scaffold
    husako()
        .args(["new", "--template", "project", target.to_str().unwrap()])
        .assert()
        .success();

    // Write k8s modules for rendering
    write_k8s_modules(&target);

    // Render
    husako_at(&target)
        .args(["render", target.join("env/dev.ts").to_str().unwrap()])
        .assert()
        .success()
        .stdout(predicates::str::contains("apiVersion: apps/v1"))
        .stdout(predicates::str::contains("kind: Deployment"))
        .stdout(predicates::str::contains("name: nginx"));
}

#[test]
fn new_then_render_multi_env() {
    let dir = tempfile::tempdir().unwrap();
    let target = dir.path().join("my-app");

    // Scaffold
    husako()
        .args(["new", "--template", "multi-env", target.to_str().unwrap()])
        .assert()
        .success();

    // Write k8s modules for rendering
    write_k8s_modules(&target);

    // Render dev
    let dev_output = husako_at(&target)
        .args(["render", target.join("dev/main.ts").to_str().unwrap()])
        .output()
        .unwrap();
    assert!(dev_output.status.success());
    let dev_yaml = String::from_utf8(dev_output.stdout).unwrap();
    assert!(dev_yaml.contains("namespace: dev"));
    assert!(dev_yaml.contains("replicas: 1"));
    assert!(dev_yaml.contains("image: nginx:latest"));

    // Render release
    let release_output = husako_at(&target)
        .args(["render", target.join("release/main.ts").to_str().unwrap()])
        .output()
        .unwrap();
    assert!(release_output.status.success());
    let release_yaml = String::from_utf8(release_output.stdout).unwrap();
    assert!(release_yaml.contains("namespace: release"));
    assert!(release_yaml.contains("replicas: 3"));
    assert!(release_yaml.contains("image: nginx:1.25"));
}

// --- Milestone 8 (Dynamic K8s Resources): New tests ---

#[test]
fn render_k8s_import_without_generate() {
    let dir = tempfile::tempdir().unwrap();
    let root = dir.path();

    let entry = root.join("entry.ts");
    std::fs::write(
        &entry,
        r#"
import { build } from "husako";
import { Deployment } from "k8s/apps/v1";
build([Deployment()]);
"#,
    )
    .unwrap();

    husako_at(root)
        .args(["render", entry.to_str().unwrap()])
        .assert()
        .code(4)
        .stderr(predicates::str::contains("husako gen"));
}

#[test]
fn generate_creates_js_modules() {
    let dir = tempfile::tempdir().unwrap();
    let root = dir.path();

    let spec_dir = root.join("specs");
    std::fs::create_dir_all(&spec_dir).unwrap();
    write_mock_spec(&spec_dir, "apis/apps/v1");

    husako_at(root)
        .args(["gen", "--spec-dir", spec_dir.to_str().unwrap()])
        .assert()
        .success();

    // .js should exist alongside .d.ts
    assert!(root.join(".husako/types/k8s/apps/v1.js").exists());

    let js = std::fs::read_to_string(root.join(".husako/types/k8s/apps/v1.js")).unwrap();
    assert!(js.contains("class _Deployment"));
    assert!(js.contains("_ResourceBuilder"));
}

#[test]
fn render_with_generated_modules() {
    let dir = tempfile::tempdir().unwrap();
    let root = dir.path();

    // Generate via husako generate
    let spec_dir = root.join("specs");
    std::fs::create_dir_all(&spec_dir).unwrap();
    write_mock_spec(&spec_dir, "apis/apps/v1");

    husako_at(root)
        .args(["gen", "--spec-dir", spec_dir.to_str().unwrap()])
        .assert()
        .success();

    // Now render using generated modules
    let entry = root.join("entry.ts");
    std::fs::write(
        &entry,
        r#"
import { build, name } from "husako";
import { Deployment } from "k8s/apps/v1";
const d = Deployment().metadata(name("test"));
build([d]);
"#,
    )
    .unwrap();

    husako_at(root)
        .args(["render", entry.to_str().unwrap()])
        .assert()
        .success()
        .stdout(predicates::str::contains("apiVersion: apps/v1"))
        .stdout(predicates::str::contains("kind: Deployment"))
        .stdout(predicates::str::contains("name: test"));
}

#[test]
fn generic_spec_setter() {
    let (dir, entry) = project_with_k8s(
        r#"
import { build, name } from "husako";
import { Namespace } from "k8s/core/v1";
const ns = Namespace()
    .metadata(name("my-ns"))
    .spec({ finalizers: ["kubernetes"] });
build([ns]);
"#,
    );
    husako_at(dir.path())
        .args(["render", entry.to_str().unwrap()])
        .assert()
        .success()
        .stdout(predicates::str::contains("kind: Namespace"))
        .stdout(predicates::str::contains("name: my-ns"))
        .stdout(predicates::str::contains("finalizers"));
}

#[test]
fn generic_set_configmap() {
    let (dir, entry) = project_with_k8s(
        r#"
import { build, name } from "husako";
import { ConfigMap } from "k8s/core/v1";
const cm = ConfigMap()
    .metadata(name("my-config"))
    .data({ key1: "val1", key2: "val2" });
build([cm]);
"#,
    );
    husako_at(dir.path())
        .args(["render", entry.to_str().unwrap()])
        .assert()
        .success()
        .stdout(predicates::str::contains("kind: ConfigMap"))
        .stdout(predicates::str::contains("key1: val1"))
        .stdout(predicates::str::contains("key2: val2"));
}

// --- Generic Builder Pattern ---

#[test]
fn builder_spec_property_methods() {
    let (dir, entry) = project_with_k8s(
        r#"
import { build, metadata } from "husako";
import { Deployment } from "k8s/apps/v1";
import { Container } from "k8s/core/v1";
import { LabelSelector } from "k8s/_common";
const d = Deployment()
    .metadata(metadata().name("nginx").label("app", "nginx"))
    .replicas(3)
    .selector(LabelSelector().matchLabels({ app: "nginx" }))
    .containers([
        Container().name("nginx").image("nginx:1.25")
    ]);
build([d]);
"#,
    );
    husako_at(dir.path())
        .args(["render", entry.to_str().unwrap()])
        .assert()
        .success()
        .stdout(predicates::str::contains("apiVersion: apps/v1"))
        .stdout(predicates::str::contains("kind: Deployment"))
        .stdout(predicates::str::contains("name: nginx"))
        .stdout(predicates::str::contains("replicas: 3"))
        .stdout(predicates::str::contains("app: nginx"))
        .stdout(predicates::str::contains("image: nginx:1.25"));
}

#[test]
fn builder_set_deep_merges() {
    let (dir, entry) = project_with_k8s(
        r#"
import { build, name } from "husako";
import { Deployment } from "k8s/apps/v1";
import { Container } from "k8s/core/v1";
const d = Deployment()
    .metadata(name("nginx"))
    .replicas(2)
    .containers([Container().name("nginx").image("nginx:1.25")])
    .initContainers([Container().name("init").image("busybox")]);
build([d]);
"#,
    );
    let output = husako_at(dir.path())
        .args(["render", entry.to_str().unwrap()])
        .output()
        .unwrap();
    assert!(output.status.success());
    let yaml = String::from_utf8(output.stdout).unwrap();
    // Both containers and initContainers should exist under template.spec
    assert!(yaml.contains("name: nginx"));
    assert!(yaml.contains("image: nginx:1.25"));
    assert!(yaml.contains("name: init"));
    assert!(yaml.contains("image: busybox"));
    assert!(yaml.contains("replicas: 2"));
}

#[test]
fn builder_spec_overrides_spec_parts() {
    let (dir, entry) = project_with_k8s(
        r#"
import { build, name } from "husako";
import { Deployment } from "k8s/apps/v1";
// .spec() should override any _specParts set via .replicas()
const d = Deployment()
    .metadata(name("nginx"))
    .replicas(3)
    .spec({ replicas: 5, selector: {} });
build([d]);
"#,
    );
    let output = husako_at(dir.path())
        .args(["render", entry.to_str().unwrap()])
        .output()
        .unwrap();
    assert!(output.status.success());
    let yaml = String::from_utf8(output.stdout).unwrap();
    // .spec() wins over .replicas()
    assert!(yaml.contains("replicas: 5"));
    assert!(!yaml.contains("replicas: 3"));
}

#[test]
fn builder_spec_parts_and_resources_merge() {
    let (dir, entry) = project_with_k8s(
        r#"
import { build, name, cpu, memory, requests, limits } from "husako";
import { Deployment } from "k8s/apps/v1";
import { Container } from "k8s/core/v1";
import { LabelSelector } from "k8s/_common";
// _specParts (from .replicas/.containers) and _resources should merge
const d = Deployment()
    .metadata(name("nginx"))
    .replicas(2)
    .selector(LabelSelector().matchLabels({ app: "nginx" }))
    .containers([
        Container().name("nginx").image("nginx:1.25")
            .resources(requests(cpu("250m").memory("128Mi")).limits(cpu("500m").memory("256Mi")))
    ]);
build([d]);
"#,
    );
    let output = husako_at(dir.path())
        .args(["render", entry.to_str().unwrap()])
        .output()
        .unwrap();
    assert!(output.status.success());
    let yaml = String::from_utf8(output.stdout).unwrap();
    // Both specParts and resources should be present
    assert!(yaml.contains("replicas: 2"));
    assert!(yaml.contains("image: nginx:1.25"));
    assert!(yaml.contains("cpu: 250m"));
    assert!(yaml.contains("memory: 128Mi"));
    assert!(yaml.contains("cpu: 500m"));
    assert!(yaml.contains("memory: 256Mi"));
}

#[test]
fn builder_copy_on_write_isolation() {
    let (dir, entry) = project_with_k8s(
        r#"
import { build, name } from "husako";
import { Deployment } from "k8s/apps/v1";
const base = Deployment().metadata(name("base")).replicas(1);
const a = base.replicas(3);
const b = base.replicas(5);
build([a, b]);
"#,
    );
    let output = husako_at(dir.path())
        .args(["render", entry.to_str().unwrap()])
        .output()
        .unwrap();
    assert!(output.status.success());
    let yaml = String::from_utf8(output.stdout).unwrap();
    assert!(yaml.contains("replicas: 3"));
    assert!(yaml.contains("replicas: 5"));
    // base's replicas=1 should not appear
    assert!(!yaml.contains("replicas: 1"));
}

#[test]
fn builder_service_spec_properties() {
    let (dir, entry) = project_with_k8s(
        r#"
import { build, name } from "husako";
import { Service } from "k8s/core/v1";
const svc = Service()
    .metadata(name("nginx"))
    .selector({ app: "nginx" })
    .ports([{ port: 80, targetPort: 8080 }])
    .type("ClusterIP");
build([svc]);
"#,
    );
    husako_at(dir.path())
        .args(["render", entry.to_str().unwrap()])
        .assert()
        .success()
        .stdout(predicates::str::contains("kind: Service"))
        .stdout(predicates::str::contains("app: nginx"))
        .stdout(predicates::str::contains("port: 80"))
        .stdout(predicates::str::contains("targetPort: 8080"))
        .stdout(predicates::str::contains("type: ClusterIP"));
}

// --- husako.toml entry aliases ---

#[test]
fn render_with_entry_alias() {
    let dir = tempfile::tempdir().unwrap();
    let root = dir.path();

    // Create husako.toml with an entry alias
    std::fs::write(
        root.join("husako.toml"),
        r#"
[entries]
dev = "env/dev.ts"

[schemas]
kubernetes = { source = "release", version = "1.35" }
"#,
    )
    .unwrap();

    // Create the entry file
    std::fs::create_dir_all(root.join("env")).unwrap();
    std::fs::write(
        root.join("env/dev.ts"),
        r#"
import { build } from "husako";
build([{ _render() { return { apiVersion: "v1", kind: "Namespace", metadata: { name: "dev" } }; } }]);
"#,
    )
    .unwrap();

    // Pre-seed .husako/types/ so auto-generate is skipped (entry file has no k8s imports).
    // Without this, husako render triggers generate  GitHub API  flaky in CI.
    std::fs::create_dir_all(root.join(".husako/types")).unwrap();

    // Render using alias
    husako_at(root)
        .args(["render", "dev"])
        .assert()
        .success()
        .stdout(predicates::str::contains("kind: Namespace"))
        .stdout(predicates::str::contains("name: dev"));
}

#[test]
fn render_alias_file_not_found() {
    let dir = tempfile::tempdir().unwrap();
    let root = dir.path();

    std::fs::write(
        root.join("husako.toml"),
        r#"
[entries]
dev = "env/dev.ts"
"#,
    )
    .unwrap();

    // File doesn't exist  should show which file the alias maps to
    husako_at(root)
        .args(["render", "dev"])
        .assert()
        .code(2)
        .stderr(predicates::str::contains("env/dev.ts"))
        .stderr(predicates::str::contains("not found"));
}

#[test]
fn render_unknown_alias_lists_available() {
    let dir = tempfile::tempdir().unwrap();
    let root = dir.path();

    std::fs::write(
        root.join("husako.toml"),
        r#"
[entries]
dev = "env/dev.ts"
staging = "env/staging.ts"
"#,
    )
    .unwrap();

    // Unknown alias  should list available aliases
    husako_at(root)
        .args(["render", "unknown"])
        .assert()
        .code(2)
        .stderr(predicates::str::contains("not a file or entry alias"))
        .stderr(predicates::str::contains("dev"))
        .stderr(predicates::str::contains("staging"));
}

#[test]
fn render_direct_path_still_works_with_config() {
    let dir = tempfile::tempdir().unwrap();
    let root = dir.path();

    // Config exists but we use direct path
    std::fs::write(
        root.join("husako.toml"),
        r#"
[entries]
alias = "other.ts"
"#,
    )
    .unwrap();

    std::fs::write(
        root.join("entry.ts"),
        r#"
import { build } from "husako";
build([{ _render() { return { apiVersion: "v1", kind: "Namespace", metadata: { name: "test" } }; } }]);
"#,
    )
    .unwrap();

    // Direct path still works
    husako_at(root)
        .args(["render", "entry.ts"])
        .assert()
        .success()
        .stdout(predicates::str::contains("kind: Namespace"));
}

#[test]
fn render_no_config_direct_path_works() {
    let dir = tempfile::tempdir().unwrap();
    let root = dir.path();

    // No husako.toml  direct path must still work
    std::fs::write(
        root.join("entry.ts"),
        r#"
import { build } from "husako";
build([{ _render() { return { apiVersion: "v1", kind: "Namespace", metadata: { name: "test" } }; } }]);
"#,
    )
    .unwrap();

    husako_at(root)
        .args(["render", "entry.ts"])
        .assert()
        .success()
        .stdout(predicates::str::contains("kind: Namespace"));
}

// --- render --output ---

const SIMPLE_NAMESPACE_TS: &str = r#"
import { build } from "husako";
build([{ _render() { return { apiVersion: "v1", kind: "Namespace", metadata: { name: "out" } }; } }]);
"#;

#[test]
fn render_output_to_yaml_file() {
    let dir = tempfile::tempdir().unwrap();
    let root = dir.path();
    std::fs::write(root.join("entry.ts"), SIMPLE_NAMESPACE_TS).unwrap();
    let out = root.join("out.yaml");

    husako_at(root)
        .args(["render", "entry.ts", "--output", out.to_str().unwrap()])
        .assert()
        .success()
        .stdout("")
        .stderr(predicates::str::contains("Written to"));

    let contents = std::fs::read_to_string(&out).unwrap();
    assert!(contents.contains("kind: Namespace"));
}

#[test]
fn render_output_to_dir_uses_stem() {
    let dir = tempfile::tempdir().unwrap();
    let root = dir.path();
    std::fs::write(root.join("entry.ts"), SIMPLE_NAMESPACE_TS).unwrap();
    let out_dir = root.join("dist");

    husako_at(root)
        .args(["render", "entry.ts", "--output", out_dir.to_str().unwrap()])
        .assert()
        .success()
        .stdout("");

    let out_file = out_dir.join("entry.yaml");
    let contents = std::fs::read_to_string(&out_file).unwrap();
    assert!(contents.contains("kind: Namespace"));
}

#[test]
fn render_output_alias_preserves_path() {
    let dir = tempfile::tempdir().unwrap();
    let root = dir.path();

    std::fs::write(
        root.join("husako.toml"),
        "[entries]\n\"apps/my-app\" = \"src/apps/my-app.ts\"\n",
    )
    .unwrap();
    std::fs::create_dir_all(root.join("src/apps")).unwrap();
    std::fs::write(root.join("src/apps/my-app.ts"), SIMPLE_NAMESPACE_TS).unwrap();
    let out_dir = root.join("dist");

    husako_at(root)
        .args([
            "render",
            "apps/my-app",
            "--output",
            out_dir.to_str().unwrap(),
        ])
        .assert()
        .success()
        .stdout("");

    // alias "apps/my-app"  dist/apps/my-app.yaml
    let out_file = out_dir.join("apps").join("my-app.yaml");
    let contents = std::fs::read_to_string(&out_file).unwrap();
    assert!(contents.contains("kind: Namespace"));
}

#[test]
fn render_output_creates_nested_dirs() {
    let dir = tempfile::tempdir().unwrap();
    let root = dir.path();
    std::fs::write(root.join("entry.ts"), SIMPLE_NAMESPACE_TS).unwrap();
    let out = root.join("a").join("b").join("c").join("out.yaml");

    husako_at(root)
        .args(["render", "entry.ts", "--output", out.to_str().unwrap()])
        .assert()
        .success();

    assert!(out.exists());
}

#[test]
fn render_output_overwrites_existing() {
    let dir = tempfile::tempdir().unwrap();
    let root = dir.path();
    std::fs::write(root.join("entry.ts"), SIMPLE_NAMESPACE_TS).unwrap();
    let out = root.join("out.yaml");
    std::fs::write(&out, "old content").unwrap();

    husako_at(root)
        .args(["render", "entry.ts", "--output", out.to_str().unwrap()])
        .assert()
        .success();

    let contents = std::fs::read_to_string(&out).unwrap();
    assert!(contents.contains("kind: Namespace"));
    assert!(!contents.contains("old content"));
}

#[test]
fn new_creates_husako_toml() {
    let dir = tempfile::tempdir().unwrap();
    let target = dir.path().join("my-app");

    husako()
        .args(["new", target.to_str().unwrap()])
        .assert()
        .success();

    assert!(target.join("husako.toml").exists());
    let content = std::fs::read_to_string(target.join("husako.toml")).unwrap();
    assert!(content.contains("[resources]"));
    assert!(content.contains("source = \"release\""));
}

#[test]
fn new_project_creates_husako_toml_with_entries() {
    let dir = tempfile::tempdir().unwrap();
    let target = dir.path().join("my-app");

    husako()
        .args(["new", "--template", "project", target.to_str().unwrap()])
        .assert()
        .success();

    let content = std::fs::read_to_string(target.join("husako.toml")).unwrap();
    assert!(content.contains("[entries]"));
    assert!(content.contains("dev"));
}

#[test]
fn new_multi_env_creates_husako_toml_with_entries() {
    let dir = tempfile::tempdir().unwrap();
    let target = dir.path().join("my-app");

    husako()
        .args(["new", "--template", "multi-env", target.to_str().unwrap()])
        .assert()
        .success();

    let content = std::fs::read_to_string(target.join("husako.toml")).unwrap();
    assert!(content.contains("[entries]"));
    assert!(content.contains("dev"));
    assert!(content.contains("staging"));
    assert!(content.contains("release"));
}

#[test]
fn new_then_render_with_alias() {
    let dir = tempfile::tempdir().unwrap();
    let target = dir.path().join("my-app");

    // Scaffold project template (has [entries] dev = "env/dev.ts")
    husako()
        .args(["new", "--template", "project", target.to_str().unwrap()])
        .assert()
        .success();

    // Write k8s modules for rendering
    write_k8s_modules(&target);

    // Render using the alias "dev" instead of "env/dev.ts"
    husako_at(&target)
        .args(["render", "dev"])
        .assert()
        .success()
        .stdout(predicates::str::contains("apiVersion: apps/v1"))
        .stdout(predicates::str::contains("kind: Deployment"))
        .stdout(predicates::str::contains("name: nginx"));
}

// --- Plugin System ---

/// Create a minimal fixture plugin under `root/.husako/plugins/<name>/`.
fn write_fixture_plugin(root: &Path, name: &str) {
    let plugin_dir = root.join(format!(".husako/plugins/{name}"));
    let modules_dir = plugin_dir.join("modules");
    std::fs::create_dir_all(&modules_dir).unwrap();

    std::fs::write(
        plugin_dir.join("plugin.toml"),
        format!(
            r#"[plugin]
name = "{name}"
version = "0.1.0"
description = "Test fixture plugin"

[modules]
"{name}" = "modules/index.js"
"{name}/sub" = "modules/sub.js"
"#
        ),
    )
    .unwrap();

    // Main module: exports a ResourceBuilder subclass
    std::fs::write(
        modules_dir.join("index.js"),
        r#"import { _ResourceBuilder } from "husako/_base";

class _TestResource extends _ResourceBuilder {
  constructor() { super("test.example.com/v1", "TestResource"); }
  message(v) { return this._setSpec("message", v); }
}
export function TestResource() { return new _TestResource(); }
"#,
    )
    .unwrap();

    // Sub-module
    std::fs::write(
        modules_dir.join("sub.js"),
        r#"import { _ResourceBuilder } from "husako/_base";

class _SubResource extends _ResourceBuilder {
  constructor() { super("test.example.com/v1", "SubResource"); }
  count(v) { return this._setSpec("count", v); }
}
export function SubResource() { return new _SubResource(); }
"#,
    )
    .unwrap();
}

#[test]
fn plugin_render_main_module() {
    let dir = tempfile::tempdir().unwrap();
    let root = dir.path();

    write_fixture_plugin(root, "testplugin");

    let entry = root.join("entry.ts");
    std::fs::write(
        &entry,
        r#"
import { build, name } from "husako";
import { TestResource } from "testplugin";
const r = TestResource().metadata(name("my-resource")).message("hello");
build([r]);
"#,
    )
    .unwrap();

    husako_at(root)
        .args(["render", entry.to_str().unwrap()])
        .assert()
        .success()
        .stdout(predicates::str::contains("apiVersion: test.example.com/v1"))
        .stdout(predicates::str::contains("kind: TestResource"))
        .stdout(predicates::str::contains("name: my-resource"))
        .stdout(predicates::str::contains("message: hello"));
}

#[test]
fn plugin_render_sub_module() {
    let dir = tempfile::tempdir().unwrap();
    let root = dir.path();

    write_fixture_plugin(root, "testplugin");

    let entry = root.join("entry.ts");
    std::fs::write(
        &entry,
        r#"
import { build, name } from "husako";
import { SubResource } from "testplugin/sub";
const r = SubResource().metadata(name("sub")).count(42);
build([r]);
"#,
    )
    .unwrap();

    husako_at(root)
        .args(["render", entry.to_str().unwrap()])
        .assert()
        .success()
        .stdout(predicates::str::contains("apiVersion: test.example.com/v1"))
        .stdout(predicates::str::contains("kind: SubResource"))
        .stdout(predicates::str::contains("count: 42"));
}

#[test]
fn plugin_import_unknown_module_exit_4() {
    let dir = tempfile::tempdir().unwrap();
    let root = dir.path();

    // No plugins installed  bare import should fail at runtime
    let entry = root.join("entry.ts");
    std::fs::write(
        &entry,
        r#"
import { build } from "husako";
import { Foo } from "nonexistent-plugin";
build([Foo()]);
"#,
    )
    .unwrap();

    husako_at(root)
        .args(["render", entry.to_str().unwrap()])
        .assert()
        .code(4);
}

#[test]
fn plugin_with_k8s_modules_together() {
    let dir = tempfile::tempdir().unwrap();
    let root = dir.path();

    write_fixture_plugin(root, "testplugin");
    write_k8s_modules(root);

    let entry = root.join("entry.ts");
    std::fs::write(
        &entry,
        r#"
import { build, name } from "husako";
import { Deployment } from "k8s/apps/v1";
import { TestResource } from "testplugin";

const dep = Deployment().metadata(name("app")).replicas(3);
const res = TestResource().metadata(name("my-res")).message("world");
build([dep, res]);
"#,
    )
    .unwrap();

    husako_at(root)
        .args(["render", entry.to_str().unwrap()])
        .assert()
        .success()
        .stdout(predicates::str::contains("kind: Deployment"))
        .stdout(predicates::str::contains("kind: TestResource"))
        .stdout(predicates::str::contains("message: world"));
}

#[test]
fn plugin_cli_list_empty() {
    let dir = tempfile::tempdir().unwrap();

    husako_at(dir.path())
        .args(["plugin", "list"])
        .assert()
        .success()
        .stderr(predicates::str::contains("No plugins installed"));
}

#[test]
fn plugin_cli_list_installed() {
    let dir = tempfile::tempdir().unwrap();
    let root = dir.path();

    write_fixture_plugin(root, "myplugin");

    husako_at(root)
        .args(["plugin", "list"])
        .assert()
        .success()
        .stderr(predicates::str::contains("myplugin"))
        .stderr(predicates::str::contains("0.1.0"));
}

#[test]
fn plugin_cli_add_path_and_remove() {
    let dir = tempfile::tempdir().unwrap();
    let root = dir.path();

    // Create husako.toml
    std::fs::write(root.join("husako.toml"), "").unwrap();

    // Create a local plugin source
    let plugin_src = root.join("my-plugin");
    std::fs::create_dir_all(&plugin_src).unwrap();
    std::fs::write(
        plugin_src.join("plugin.toml"),
        "[plugin]\nname = \"test\"\nversion = \"0.1.0\"\n",
    )
    .unwrap();

    // Add the plugin
    husako_at(root)
        .args(["plugin", "add", "test", "--path", "my-plugin"])
        .assert()
        .success();

    // Verify it was added to husako.toml
    let config_content = std::fs::read_to_string(root.join("husako.toml")).unwrap();
    assert!(config_content.contains("[plugins]"));
    assert!(config_content.contains("test"));
    assert!(config_content.contains("my-plugin"));

    // Remove the plugin
    husako_at(root)
        .args(["plugin", "remove", "test"])
        .assert()
        .success();

    // Verify it was removed from husako.toml
    let config_content = std::fs::read_to_string(root.join("husako.toml")).unwrap();
    assert!(!config_content.contains("test"));
}

// --- FluxCD Plugin ---

/// Install the bundled fluxcd plugin into `.husako/plugins/fluxcd/` for test isolation.
fn install_flux_plugin(root: &Path) {
    let plugin_dir = root.join(".husako/plugins/fluxcd");
    let modules_dir = plugin_dir.join("modules");
    std::fs::create_dir_all(&modules_dir).unwrap();

    std::fs::write(
        plugin_dir.join("plugin.toml"),
        include_str!("../../../plugins/fluxcd/plugin.toml"),
    )
    .unwrap();
    std::fs::write(
        modules_dir.join("source.js"),
        include_str!("../../../plugins/fluxcd/modules/source.js"),
    )
    .unwrap();
    std::fs::write(
        modules_dir.join("index.js"),
        include_str!("../../../plugins/fluxcd/modules/index.js"),
    )
    .unwrap();
}

#[test]
fn flux_plugin_helm_release() {
    let dir = tempfile::tempdir().unwrap();
    let root = dir.path();

    install_flux_plugin(root);

    let entry = root.join("entry.ts");
    std::fs::write(
        &entry,
        r#"
import { build, name, namespace } from "husako";
import { HelmRelease, HelmRepository } from "fluxcd";

const repo = HelmRepository()
    .metadata(name("bitnami").namespace("flux-system"))
    .url("https://charts.bitnami.com/bitnami")
    .interval("1h");

const release = HelmRelease()
    .metadata(name("redis").namespace("default"))
    .chart("redis", "18.0.0")
    .sourceRef(repo)
    .interval("5m")
    .values({ architecture: "standalone" });

build([repo, release]);
"#,
    )
    .unwrap();

    husako_at(root)
        .args(["render", entry.to_str().unwrap()])
        .assert()
        .success()
        .stdout(predicates::str::contains(
            "apiVersion: source.toolkit.fluxcd.io/v1",
        ))
        .stdout(predicates::str::contains("kind: HelmRepository"))
        .stdout(predicates::str::contains("name: bitnami"))
        .stdout(predicates::str::contains(
            "apiVersion: helm.toolkit.fluxcd.io/v2",
        ))
        .stdout(predicates::str::contains("kind: HelmRelease"))
        .stdout(predicates::str::contains("name: redis"))
        .stdout(predicates::str::contains("chart: redis"))
        .stdout(predicates::str::contains("version: 18.0.0"))
        .stdout(predicates::str::contains("architecture: standalone"));
}

#[test]
fn flux_plugin_kustomization() {
    let dir = tempfile::tempdir().unwrap();
    let root = dir.path();

    install_flux_plugin(root);

    let entry = root.join("entry.ts");
    std::fs::write(
        &entry,
        r#"
import { build, name, namespace } from "husako";
import { Kustomization } from "fluxcd";
import { GitRepository } from "fluxcd/source";

const repo = GitRepository()
    .metadata(name("infra").namespace("flux-system"))
    .url("https://github.com/example/infra")
    .ref({ branch: "main" })
    .interval("5m");

const ks = Kustomization()
    .metadata(name("infra").namespace("flux-system"))
    .sourceRef(repo)
    .path("./clusters/production")
    .interval("10m")
    .prune(true)
    .targetNamespace("default");

build([repo, ks]);
"#,
    )
    .unwrap();

    husako_at(root)
        .args(["render", entry.to_str().unwrap()])
        .assert()
        .success()
        .stdout(predicates::str::contains(
            "apiVersion: source.toolkit.fluxcd.io/v1",
        ))
        .stdout(predicates::str::contains("kind: GitRepository"))
        .stdout(predicates::str::contains("name: infra"))
        .stdout(predicates::str::contains(
            "apiVersion: kustomize.toolkit.fluxcd.io/v1",
        ))
        .stdout(predicates::str::contains("kind: Kustomization"))
        .stdout(predicates::str::contains("path: ./clusters/production"))
        .stdout(predicates::str::contains("prune: true"))
        .stdout(predicates::str::contains("targetNamespace: default"));
}

#[test]
fn flux_plugin_source_ref_linking() {
    let dir = tempfile::tempdir().unwrap();
    let root = dir.path();

    install_flux_plugin(root);

    let entry = root.join("entry.ts");
    std::fs::write(
        &entry,
        r#"
import { build, name, namespace } from "husako";
import { HelmRelease, HelmRepository } from "fluxcd";

const repo = HelmRepository("charts")
    .metadata(name("charts").namespace("flux-system"))
    .url("https://charts.example.com")
    .interval("1h");

const release = HelmRelease("app")
    .chart("my-app", "1.0.0")
    .sourceRef(repo);

build([release]);
"#,
    )
    .unwrap();

    let output = husako_at(root)
        .args(["render", entry.to_str().unwrap()])
        .output()
        .unwrap();
    assert!(output.status.success());
    let yaml = String::from_utf8(output.stdout).unwrap();
    // sourceRef should be resolved from the HelmRepository builder
    assert!(yaml.contains("kind: HelmRepository"));
    assert!(yaml.contains("name: charts"));
    assert!(yaml.contains("namespace: flux-system"));
}

#[test]
fn flux_plugin_values_plain_object() {
    let dir = tempfile::tempdir().unwrap();
    let root = dir.path();

    install_flux_plugin(root);

    let entry = root.join("entry.ts");
    std::fs::write(
        &entry,
        r#"
import { build, name } from "husako";
import { HelmRelease } from "fluxcd";

const release = HelmRelease("app")
    .chart("my-app", 2.0)
    .values({ replicas: 3, image: { tag: "latest" } });

build([release]);
"#,
    )
    .unwrap();

    husako_at(root)
        .args(["render", entry.to_str().unwrap()])
        .assert()
        .success()
        .stdout(predicates::str::contains("kind: HelmRelease"))
        .stdout(predicates::str::contains("chart: my-app"))
        .stdout(predicates::str::contains("version: '2'"))
        .stdout(predicates::str::contains("replicas: 3"))
        .stdout(predicates::str::contains("tag: latest"));
}

#[test]
fn flux_plugin_re_exports() {
    let dir = tempfile::tempdir().unwrap();
    let root = dir.path();

    install_flux_plugin(root);

    // Import GitRepository from "fluxcd" (re-exported) instead of "fluxcd/source"
    let entry = root.join("entry.ts");
    std::fs::write(
        &entry,
        r#"
import { build, name } from "husako";
import { GitRepository } from "fluxcd";

const repo = GitRepository("my-repo")
    .url("https://github.com/example/repo")
    .ref({ tag: "v1.0.0" })
    .interval("5m");

build([repo]);
"#,
    )
    .unwrap();

    husako_at(root)
        .args(["render", entry.to_str().unwrap()])
        .assert()
        .success()
        .stdout(predicates::str::contains(
            "apiVersion: source.toolkit.fluxcd.io/v1",
        ))
        .stdout(predicates::str::contains("kind: GitRepository"))
        .stdout(predicates::str::contains("name: my-repo"))
        .stdout(predicates::str::contains("tag: v1.0.0"));
}

// --- husako add error cases ---

#[test]
fn add_no_args_errors() {
    let dir = tempfile::tempdir().unwrap();
    let root = dir.path();
    std::fs::write(root.join("husako.toml"), "[resources]\n").unwrap();

    husako_at(root).args(["add"]).assert().failure().code(2);
}

#[test]
fn add_registry_missing_name_errors() {
    let dir = tempfile::tempdir().unwrap();
    let root = dir.path();
    std::fs::write(root.join("husako.toml"), "[charts]\n").unwrap();

    husako_at(root)
        .args(["add", "https://charts.jetstack.io"])
        .assert()
        .failure()
        .code(2);
}

#[test]
fn add_unrecognized_url_errors() {
    let dir = tempfile::tempdir().unwrap();
    let root = dir.path();
    std::fs::write(root.join("husako.toml"), "[resources]\n").unwrap();

    husako_at(root)
        .args(["add", "foo_unknown_bar"])
        .assert()
        .failure()
        .code(2);
}

// --- husako gen: no-op path ---

#[test]
fn gen_no_config_prints_already_up_to_date() {
    let dir = tempfile::tempdir().unwrap();
    // No husako.toml, no config  generate has nothing to do.
    husako_at(dir.path())
        .args(["gen"])
        .assert()
        .success()
        .stdout(predicates::str::contains("Already up to date"));
}

// --- husako check ---

#[test]
fn check_valid_ts_succeeds() {
    let dir = tempfile::tempdir().unwrap();
    let root = dir.path();
    let entry = root.join("entry.ts");
    std::fs::write(
        &entry,
        r#"import { build } from "husako";
build([{ _render() { return { apiVersion: "v1", kind: "Namespace", metadata: { name: "dev" } }; } }]);
"#,
    )
    .unwrap();

    husako_at(root)
        .args(["check", entry.to_str().unwrap()])
        .assert()
        .success()
        .stderr(predicates::str::contains("compiles successfully"))
        .stderr(predicates::str::contains("husako.build() called with 1"));
}

#[test]
fn check_invalid_ts_fails() {
    let dir = tempfile::tempdir().unwrap();
    let root = dir.path();
    let entry = root.join("entry.ts");
    std::fs::write(&entry, "const x: string = 42;\n").unwrap();

    husako_at(root)
        .args(["check", entry.to_str().unwrap()])
        .assert()
        .failure();
}

#[test]
fn check_missing_build_call_fails() {
    let dir = tempfile::tempdir().unwrap();
    let root = dir.path();
    let entry = root.join("entry.ts");
    // Valid TS but no husako.build() call  exit 7
    std::fs::write(&entry, "const x = 1;\n").unwrap();

    husako_at(root)
        .args(["check", entry.to_str().unwrap()])
        .assert()
        .failure()
        .code(7);
}

#[test]
fn check_with_k8s_builder_and_ts_types_succeeds() {
    let (_dir, entry) = project_with_k8s(
        r#"import { build, name, namespace, label } from "husako";
import { Deployment } from "k8s/apps/v1";

interface AppConfig {
    appName: string;
    replicas: number;
}

function makeDeployment(config: AppConfig) {
    return Deployment()
        .metadata(name(config.appName).namespace("default").label("app", config.appName))
        .replicas(config.replicas);
}

const deploy = makeDeployment({ appName: "nginx", replicas: 3 });
build([deploy]);
"#,
    );

    husako_at(entry.parent().unwrap())
        .args(["check", entry.to_str().unwrap()])
        .assert()
        .success()
        .stderr(predicates::str::contains("compiles successfully"))
        .stderr(predicates::str::contains("husako.build() called with 1"));
}

#[test]
fn check_with_multiple_resources_succeeds() {
    let (_dir, entry) = project_with_k8s(
        r#"import { build, name, namespace } from "husako";
import { Deployment } from "k8s/apps/v1";
import { Namespace } from "k8s/core/v1";

const ns = Namespace().metadata(name("myapp"));
const deploy = Deployment()
    .metadata(name("myapp").namespace("myapp"))
    .replicas(1);

build([ns, deploy]);
"#,
    );

    husako_at(entry.parent().unwrap())
        .args(["check", entry.to_str().unwrap()])
        .assert()
        .success()
        .stderr(predicates::str::contains("compiles successfully"))
        .stderr(predicates::str::contains("husako.build() called with 2"));
}

#[test]
fn check_typescript_syntax_features_succeed() {
    let (_dir, entry) = project_with_k8s(
        r#"import { build, name } from "husako";
import { Deployment } from "k8s/apps/v1";

type Env = "dev" | "prod";

enum Scale {
    Small = 1,
    Large = 3,
}

function makeReplicas(env: Env): number {
    return env === "prod" ? Scale.Large : Scale.Small;
}

function makeDeployment<T extends { name: string }>(meta: T, env: Env) {
    return Deployment()
        .metadata(name(meta.name))
        .replicas(makeReplicas(env));
}

const deploy = makeDeployment({ name: "api" }, "prod" as Env);
build([deploy]);
"#,
    );

    husako_at(entry.parent().unwrap())
        .args(["check", entry.to_str().unwrap()])
        .assert()
        .success()
        .stderr(predicates::str::contains("compiles successfully"))
        .stderr(predicates::str::contains("husako.build() called with 1"));
}

#[test]
fn check_compile_error_exits_3() {
    let f = write_temp_ts("const = ;\n");
    husako()
        .args(["check", f.path().to_str().unwrap()])
        .assert()
        .code(3);
}

// ============================================================
// Track A: tests requiring no network calls
// ============================================================

// --- husako clean ---

const K8S_METALLB_TOML: &str = r#"
[resources]
k8s = { source = "release", version = "1.35" }

[charts]
metallb = { source = "artifacthub", package = "metallb/metallb", version = "0.15.3" }
"#;

#[test]
fn clean_removes_types_dir() {
    let dir = tempfile::tempdir().unwrap();
    let root = dir.path();
    let types_dir = root.join(".husako/types");
    std::fs::create_dir_all(&types_dir).unwrap();
    std::fs::write(types_dir.join("dummy.d.ts"), "").unwrap();

    husako_at(root)
        .args(["clean", "--types"])
        .assert()
        .success()
        .stderr(predicates::str::contains(".husako/types/"));

    assert!(!types_dir.exists(), ".husako/types/ should be removed");
}

#[test]
fn clean_removes_cache_dir() {
    let dir = tempfile::tempdir().unwrap();
    let root = dir.path();
    let cache_dir = root.join(".husako/cache");
    std::fs::create_dir_all(&cache_dir).unwrap();
    std::fs::write(cache_dir.join("dummy.json"), "{}").unwrap();

    husako_at(root)
        .args(["clean", "--cache"])
        .assert()
        .success()
        .stderr(predicates::str::contains(".husako/cache/"));

    assert!(!cache_dir.exists(), ".husako/cache/ should be removed");
}

#[test]
fn clean_removes_all() {
    let dir = tempfile::tempdir().unwrap();
    let root = dir.path();
    let types_dir = root.join(".husako/types");
    let cache_dir = root.join(".husako/cache");
    std::fs::create_dir_all(&types_dir).unwrap();
    std::fs::create_dir_all(&cache_dir).unwrap();
    std::fs::write(types_dir.join("dummy.d.ts"), "").unwrap();
    std::fs::write(cache_dir.join("dummy.json"), "{}").unwrap();

    husako_at(root).args(["clean", "--all"]).assert().success();

    assert!(!types_dir.exists(), ".husako/types/ should be removed");
    assert!(!cache_dir.exists(), ".husako/cache/ should be removed");
}

// --- husako init ---

#[test]
fn init_creates_project_files() {
    let dir = tempfile::tempdir().unwrap();
    let root = dir.path();

    husako_at(root).args(["init"]).assert().success();

    assert!(
        root.join("husako.toml").exists(),
        "husako.toml should be created in current dir"
    );
}

#[test]
fn init_with_project_template() {
    let dir = tempfile::tempdir().unwrap();
    let root = dir.path();

    husako_at(root)
        .args(["init", "--template", "project"])
        .assert()
        .success();

    let content = std::fs::read_to_string(root.join("husako.toml")).unwrap();
    assert!(
        content.contains("[entries]"),
        "project template should include [entries] section"
    );
}

// --- husako list / husako ls ---

#[test]
fn list_resources_from_config() {
    let dir = tempfile::tempdir().unwrap();
    let root = dir.path();
    std::fs::write(root.join("husako.toml"), K8S_METALLB_TOML).unwrap();

    husako_at(root)
        .args(["list"])
        .assert()
        .success()
        .stderr(predicates::str::contains("k8s"))
        .stderr(predicates::str::contains("metallb"));
}

#[test]
fn list_resources_only_flag() {
    let dir = tempfile::tempdir().unwrap();
    let root = dir.path();
    std::fs::write(root.join("husako.toml"), K8S_METALLB_TOML).unwrap();

    let output = husako_at(root)
        .args(["list", "--resources"])
        .output()
        .unwrap();

    let stderr = String::from_utf8_lossy(&output.stderr);
    assert!(output.status.success());
    assert!(stderr.contains("k8s"), "should contain k8s");
    assert!(!stderr.contains("metallb"), "should not contain metallb");
}

#[test]
fn list_charts_only_flag() {
    let dir = tempfile::tempdir().unwrap();
    let root = dir.path();
    std::fs::write(root.join("husako.toml"), K8S_METALLB_TOML).unwrap();

    let output = husako_at(root).args(["list", "--charts"]).output().unwrap();

    let stderr = String::from_utf8_lossy(&output.stderr);
    assert!(output.status.success());
    assert!(stderr.contains("metallb"), "should contain metallb");
    assert!(!stderr.contains("k8s"), "should not contain k8s");
}

#[test]
fn list_empty_no_config() {
    let dir = tempfile::tempdir().unwrap();
    husako_at(dir.path()).args(["list"]).assert().success();
}

#[test]
fn ls_alias_works() {
    let dir = tempfile::tempdir().unwrap();
    let root = dir.path();
    std::fs::write(root.join("husako.toml"), K8S_METALLB_TOML).unwrap();

    husako_at(root)
        .args(["ls"])
        .assert()
        .success()
        .stderr(predicates::str::contains("k8s"))
        .stderr(predicates::str::contains("metallb"));
}

// --- husako remove / husako rm ---

#[test]
fn remove_resource_from_config() {
    let dir = tempfile::tempdir().unwrap();
    let root = dir.path();
    std::fs::write(
        root.join("husako.toml"),
        "[resources]\nk8s = { source = \"release\", version = \"1.35\" }\n",
    )
    .unwrap();

    husako_at(root)
        .args(["remove", "k8s"])
        .assert()
        .success()
        .stderr(predicates::str::contains("Removed k8s"));

    let content = std::fs::read_to_string(root.join("husako.toml")).unwrap();
    assert!(
        !content.contains("k8s"),
        "k8s should be removed from config"
    );
}

#[test]
fn remove_chart_from_config() {
    let dir = tempfile::tempdir().unwrap();
    let root = dir.path();
    std::fs::write(
        root.join("husako.toml"),
        "[charts]\nmetallb = { source = \"artifacthub\", package = \"metallb/metallb\", version = \"0.15.3\" }\n",
    )
    .unwrap();

    husako_at(root)
        .args(["remove", "metallb"])
        .assert()
        .success()
        .stderr(predicates::str::contains("Removed metallb"));

    let content = std::fs::read_to_string(root.join("husako.toml")).unwrap();
    assert!(
        !content.contains("metallb"),
        "metallb should be removed from config"
    );
}

#[test]
fn remove_nonexistent_errors() {
    let dir = tempfile::tempdir().unwrap();
    let root = dir.path();
    std::fs::write(
        root.join("husako.toml"),
        "[resources]\nk8s = { source = \"release\", version = \"1.35\" }\n",
    )
    .unwrap();

    husako_at(root)
        .args(["remove", "nonexistent"])
        .assert()
        .failure()
        .stderr(predicates::str::contains("not found"));
}

#[test]
fn rm_alias_works() {
    let dir = tempfile::tempdir().unwrap();
    let root = dir.path();
    std::fs::write(
        root.join("husako.toml"),
        "[resources]\nk8s = { source = \"release\", version = \"1.35\" }\n",
    )
    .unwrap();

    husako_at(root)
        .args(["rm", "k8s"])
        .assert()
        .success()
        .stderr(predicates::str::contains("Removed k8s"));
}

// --- husako info ---

#[test]
fn info_no_config() {
    let dir = tempfile::tempdir().unwrap();
    husako_at(dir.path()).args(["info"]).assert().success();
}

#[test]
fn info_with_config() {
    let dir = tempfile::tempdir().unwrap();
    let root = dir.path();
    std::fs::write(root.join("husako.toml"), K8S_METALLB_TOML).unwrap();

    husako_at(root)
        .args(["info"])
        .assert()
        .success()
        .stderr(predicates::str::contains("k8s"))
        .stderr(predicates::str::contains("metallb"));
}

#[test]
fn info_with_types_dir() {
    let dir = tempfile::tempdir().unwrap();
    let root = dir.path();
    std::fs::write(root.join("husako.toml"), K8S_METALLB_TOML).unwrap();
    let types_dir = root.join(".husako/types");
    std::fs::create_dir_all(&types_dir).unwrap();
    std::fs::write(types_dir.join("some.d.ts"), "").unwrap();

    husako_at(root).args(["info"]).assert().success();
}

#[test]
fn info_dependency_detail() {
    let dir = tempfile::tempdir().unwrap();
    let root = dir.path();
    std::fs::write(
        root.join("husako.toml"),
        "[resources]\nk8s = { source = \"release\", version = \"1.35\" }\n",
    )
    .unwrap();

    husako_at(root)
        .args(["info", "k8s"])
        .assert()
        .success()
        .stderr(predicates::str::contains("k8s"))
        .stderr(predicates::str::contains("1.35"));
}

#[test]
fn info_dependency_not_found_errors() {
    let dir = tempfile::tempdir().unwrap();
    let root = dir.path();
    std::fs::write(
        root.join("husako.toml"),
        "[resources]\nk8s = { source = \"release\", version = \"1.35\" }\n",
    )
    .unwrap();

    husako_at(root)
        .args(["info", "nonexistent"])
        .assert()
        .failure()
        .stderr(predicates::str::contains("not found"));
}

// --- husako debug ---

#[test]
fn debug_no_config() {
    let dir = tempfile::tempdir().unwrap();
    husako_at(dir.path())
        .args(["debug"])
        .assert()
        .success()
        .stderr(predicates::str::contains("husako.toml not found"));
}

#[test]
fn debug_with_types_present() {
    let dir = tempfile::tempdir().unwrap();
    let root = dir.path();
    std::fs::write(root.join("husako.toml"), K8S_METALLB_TOML).unwrap();
    let types_dir = root.join(".husako/types");
    std::fs::create_dir_all(&types_dir).unwrap();
    std::fs::write(types_dir.join("some.d.ts"), "").unwrap();

    husako_at(root)
        .args(["debug"])
        .assert()
        .success()
        .stderr(predicates::str::contains(".husako/types/ exists"));
}

#[test]
fn debug_missing_types_shows_warning() {
    let dir = tempfile::tempdir().unwrap();
    let root = dir.path();
    std::fs::write(root.join("husako.toml"), K8S_METALLB_TOML).unwrap();
    // No .husako/types/ directory

    husako_at(root)
        .args(["debug"])
        .assert()
        .success()
        .stderr(predicates::str::contains(
            ".husako/types/ directory not found",
        ));
}

// --- husako test ---

#[test]
fn test_passing_tests_exit_0() {
    let dir = tempfile::tempdir().unwrap();
    let root = dir.path();
    std::fs::write(
        root.join("entry.test.ts"),
        r#"import { test, describe } from "husako/test";
describe("suite", () => {
    test("passes", () => {
        if (1 !== 1) throw new Error("should not fail");
    });
});
"#,
    )
    .unwrap();

    husako_at(root)
        .args(["test", "entry.test.ts"])
        .assert()
        .success();
}

#[test]
fn test_failing_tests_exit_nonzero() {
    let dir = tempfile::tempdir().unwrap();
    let root = dir.path();
    std::fs::write(
        root.join("entry.test.ts"),
        r#"import { test } from "husako/test";
test("fails", () => { throw new Error("intentional failure"); });
"#,
    )
    .unwrap();

    husako_at(root)
        .args(["test", "entry.test.ts"])
        .assert()
        .failure();
}

#[test]
fn test_no_test_file_errors() {
    let dir = tempfile::tempdir().unwrap();
    let root = dir.path();

    husako_at(root)
        .args(["test", "nonexistent.test.ts"])
        .assert()
        .failure();
}

#[test]
fn test_auto_discovery_no_files() {
    let dir = tempfile::tempdir().unwrap();
    // Empty dir  no *.test.ts or *.spec.ts files

    husako_at(dir.path())
        .args(["test"])
        .assert()
        .success()
        .stderr(predicates::str::contains("No test files found"));
}

// --- husako gen: lock-based skip ---

/// Seed `.husako/cache/release/v{tag}/` with a minimal valid OpenAPI spec
/// so `fetch_release_specs()` is a cache hit  no network needed.
fn write_release_cache(root: &Path, version: &str) {
    let v = version.strip_prefix('v').unwrap_or(version);
    let parts: Vec<&str> = v.split('.').collect();
    let tag = if parts.len() == 2 {
        format!("v{v}.0")
    } else {
        format!("v{v}")
    };
    let cache_dir = root.join(format!(".husako/cache/release/{tag}"));
    std::fs::create_dir_all(&cache_dir).unwrap();

    let spec = rich_mock_spec();
    std::fs::write(
        cache_dir.join("apis__apps__v1_openapi.json"),
        spec.to_string(),
    )
    .unwrap();

    let manifest: Vec<(String, String)> = vec![(
        "apis/apps/v1".to_string(),
        "apis__apps__v1_openapi.json".to_string(),
    )];
    std::fs::write(
        cache_dir.join("_manifest.json"),
        serde_json::to_string(&manifest).unwrap(),
    )
    .unwrap();
}

/// Compute a djb2 hash string identical to `husako_helm::cache_hash()`.
fn chart_djb2(s: &str) -> String {
    let mut hash: u64 = 5381;
    for byte in s.bytes() {
        hash = hash.wrapping_mul(33).wrapping_add(u64::from(byte));
    }
    format!("{hash:016x}")
}

/// Seed `.husako/cache/helm/artifacthub/{hash}/{version}.json` with a
/// minimal JSON Schema so the chart resolver is a cache hit.
fn write_artifacthub_chart_cache(root: &Path, package: &str, version: &str) {
    let cache_key = chart_djb2(package);
    let cache_dir = root.join(format!(".husako/cache/helm/artifacthub/{cache_key}"));
    std::fs::create_dir_all(&cache_dir).unwrap();
    let schema = serde_json::json!({
        "type": "object",
        "properties": { "replicaCount": { "type": "integer" } }
    });
    std::fs::write(
        cache_dir.join(format!("{version}.json")),
        serde_json::to_string(&schema).unwrap(),
    )
    .unwrap();
}

#[test]
fn gen_with_lock_skips_unchanged_resources() {
    let dir = tempfile::tempdir().unwrap();
    let root = dir.path();

    std::fs::write(
        root.join("husako.toml"),
        "[resources]\nk8s = { source = \"release\", version = \"1.35\" }\n",
    )
    .unwrap();

    // Write a lock file that matches current config + husako version
    std::fs::write(
        root.join("husako.lock"),
        "# This file is generated by husako. Commit it to version control.\n\
         # Do not edit it manually.\n\n\
         format_version = 1\n\
         husako_version = \"0.1.0\"\n\n\
         [resources.k8s]\n\
         source = \"release\"\n\
         version = \"1.35\"\n\
         generated_at = \"2024-01-01T00:00:00Z\"\n",
    )
    .unwrap();

    // Pre-seed .husako/types/k8s/ with some files so the dir is non-empty
    let k8s_dir = root.join(".husako/types/k8s");
    std::fs::create_dir_all(k8s_dir.join("apps")).unwrap();
    std::fs::write(k8s_dir.join("apps/v1.d.ts"), "// generated").unwrap();

    husako_at(root)
        .args(["gen"])
        .assert()
        .success()
        .stdout(predicates::str::contains("Already up to date"));
}

#[test]
fn gen_no_incremental_ignores_lock() {
    let dir = tempfile::tempdir().unwrap();
    let root = dir.path();

    std::fs::write(
        root.join("husako.toml"),
        "[resources]\nk8s = { source = \"release\", version = \"1.35\" }\n",
    )
    .unwrap();

    // Lock says current version  would skip without --no-incremental
    std::fs::write(
        root.join("husako.lock"),
        "# This file is generated by husako. Commit it to version control.\n\
         # Do not edit it manually.\n\n\
         format_version = 1\n\
         husako_version = \"0.1.0\"\n\n\
         [resources.k8s]\n\
         source = \"release\"\n\
         version = \"1.35\"\n\
         generated_at = \"2024-01-01T00:00:00Z\"\n",
    )
    .unwrap();

    // Seed release cache so generation can complete without network
    write_release_cache(root, "1.35");

    husako_at(root)
        .args(["gen", "--no-incremental"])
        .assert()
        .success();

    // Generation ran  types dir was created
    assert!(
        root.join(".husako/types/k8s").exists(),
        ".husako/types/k8s/ should be created"
    );
}

// --- husako render: -o short flag ---

#[test]
fn render_short_o_flag_writes_file() {
    let dir = tempfile::tempdir().unwrap();
    let root = dir.path();
    let entry = root.join("entry.ts");
    std::fs::write(
        &entry,
        r#"import { build } from "husako";
build([{ _render() { return { apiVersion: "v1", kind: "Namespace", metadata: { name: "dev" } }; } }]);
"#,
    )
    .unwrap();

    let out = root.join("out.yaml");
    husako_at(root)
        .args([
            "render",
            entry.to_str().unwrap(),
            "-o",
            out.to_str().unwrap(),
        ])
        .assert()
        .success();

    assert!(out.exists(), "out.yaml should be written");
    assert!(
        out.metadata().unwrap().len() > 0,
        "out.yaml should not be empty"
    );
}

// --- husako add: duplicate cases (no network needed) ---

#[test]
fn add_duplicate_resource_shows_message() {
    let dir = tempfile::tempdir().unwrap();
    let root = dir.path();
    std::fs::write(
        root.join("husako.toml"),
        "[resources]\nk8s = { source = \"release\", version = \"1.35\" }\n",
    )
    .unwrap();

    // --release branch returns without network; AlreadyExists does not regen
    husako_at(root)
        .args(["add", "--release", "1.35", "--name", "k8s"])
        .assert()
        .success()
        .stderr(predicates::str::contains("already in"));

    // toml unchanged
    let content = std::fs::read_to_string(root.join("husako.toml")).unwrap();
    assert_eq!(
        content.trim(),
        "[resources]\nk8s = { source = \"release\", version = \"1.35\" }",
    );
}

// --- husako outdated: no config ---

#[test]
fn outdated_no_config_shows_no_deps() {
    let dir = tempfile::tempdir().unwrap();
    husako_at(dir.path())
        .args(["outdated"])
        .assert()
        .success()
        .stderr(predicates::str::contains("No versioned dependencies found"));
}

// ============================================================
// Track B: tests using mockito + env var URL injection
// ============================================================

#[tokio::test]
async fn outdated_release_source_newer_available() {
    let mut server = mockito::Server::new_async().await;
    let _m = server
        .mock("GET", "/repos/kubernetes/kubernetes/tags?per_page=100")
        .with_status(200)
        .with_header("content-type", "application/json")
        .with_body(r#"[{"name":"v1.35.0"},{"name":"v1.34.3"}]"#)
        .create_async()
        .await;

    let dir = tempfile::tempdir().unwrap();
    let root = dir.path();
    std::fs::write(
        root.join("husako.toml"),
        "[resources]\nk8s = { source = \"release\", version = \"1.34\" }\n",
    )
    .unwrap();

    husako_at(root)
        .args(["outdated"])
        .env("HUSAKO_GITHUB_API_URL", server.url())
        .assert()
        .success()
        .stderr(predicates::str::contains("1.34"))
        .stderr(predicates::str::contains("1.35"));
}

#[tokio::test]
async fn outdated_release_source_up_to_date() {
    let mut server = mockito::Server::new_async().await;
    let _m = server
        .mock("GET", "/repos/kubernetes/kubernetes/tags?per_page=100")
        .with_status(200)
        .with_header("content-type", "application/json")
        .with_body(r#"[{"name":"v1.35.0"}]"#)
        .create_async()
        .await;

    let dir = tempfile::tempdir().unwrap();
    let root = dir.path();
    std::fs::write(
        root.join("husako.toml"),
        "[resources]\nk8s = { source = \"release\", version = \"1.35\" }\n",
    )
    .unwrap();

    husako_at(root)
        .args(["outdated"])
        .env("HUSAKO_GITHUB_API_URL", server.url())
        .assert()
        .success()
        .stderr(predicates::str::contains("up to date"));
}

#[tokio::test]
async fn outdated_artifacthub_chart_newer_available() {
    let mut server = mockito::Server::new_async().await;
    let _m = server
        .mock("GET", "/api/v1/packages/helm/metallb/metallb")
        .with_status(200)
        .with_header("content-type", "application/json")
        .with_body(r#"{"version":"0.15.3","available_versions":[]}"#)
        .create_async()
        .await;

    let dir = tempfile::tempdir().unwrap();
    let root = dir.path();
    std::fs::write(
        root.join("husako.toml"),
        "[charts]\nmetallb = { source = \"artifacthub\", package = \"metallb/metallb\", version = \"0.14.0\" }\n",
    )
    .unwrap();

    husako_at(root)
        .args(["outdated"])
        .env("HUSAKO_ARTIFACTHUB_URL", server.url())
        .assert()
        .success()
        .stderr(predicates::str::contains("0.14.0"))
        .stderr(predicates::str::contains("0.15.3"));
}

#[tokio::test]
async fn outdated_network_error_graceful() {
    let mut server = mockito::Server::new_async().await;
    let _m = server
        .mock("GET", "/repos/kubernetes/kubernetes/tags?per_page=100")
        .with_status(500)
        .create_async()
        .await;

    let dir = tempfile::tempdir().unwrap();
    let root = dir.path();
    std::fs::write(
        root.join("husako.toml"),
        "[resources]\nk8s = { source = \"release\", version = \"1.34\" }\n",
    )
    .unwrap();

    // Error is logged per-entry; overall command still exits 0
    husako_at(root)
        .args(["outdated"])
        .env("HUSAKO_GITHUB_API_URL", server.url())
        .assert()
        .success();
}

#[tokio::test]
async fn update_bumps_resource_version_in_toml() {
    let mut server = mockito::Server::new_async().await;
    let _m = server
        .mock("GET", "/repos/kubernetes/kubernetes/tags?per_page=100")
        .with_status(200)
        .with_header("content-type", "application/json")
        .with_body(r#"[{"name":"v1.35.0"}]"#)
        .create_async()
        .await;

    let dir = tempfile::tempdir().unwrap();
    let root = dir.path();
    std::fs::write(
        root.join("husako.toml"),
        "[resources]\nk8s = { source = \"release\", version = \"1.34\" }\n",
    )
    .unwrap();

    // Pre-seed release cache for auto-regen after update
    write_release_cache(root, "1.35");

    husako_at(root)
        .args(["update"])
        .env("HUSAKO_GITHUB_API_URL", server.url())
        .assert()
        .success()
        .stderr(predicates::str::contains("Updated"))
        .stderr(predicates::str::contains("k8s"));

    let content = std::fs::read_to_string(root.join("husako.toml")).unwrap();
    assert!(
        content.contains("1.35"),
        "husako.toml should be updated to version 1.35"
    );
}

#[tokio::test]
async fn update_dry_run_does_not_modify_toml() {
    let mut server = mockito::Server::new_async().await;
    let _m = server
        .mock("GET", "/repos/kubernetes/kubernetes/tags?per_page=100")
        .with_status(200)
        .with_header("content-type", "application/json")
        .with_body(r#"[{"name":"v1.35.0"}]"#)
        .create_async()
        .await;

    let dir = tempfile::tempdir().unwrap();
    let root = dir.path();
    let toml_content = "[resources]\nk8s = { source = \"release\", version = \"1.34\" }\n";
    std::fs::write(root.join("husako.toml"), toml_content).unwrap();

    husako_at(root)
        .args(["update", "--dry-run"])
        .env("HUSAKO_GITHUB_API_URL", server.url())
        .assert()
        .success()
        .stderr(predicates::str::contains("Would update"));

    let content = std::fs::read_to_string(root.join("husako.toml")).unwrap();
    assert!(
        content.contains("1.34"),
        "husako.toml should still contain 1.34 after --dry-run"
    );
    assert!(
        !content.contains("1.35"),
        "husako.toml should not be updated in dry-run mode"
    );
}

#[tokio::test]
async fn update_resources_only_skips_charts() {
    // GitHub API mock for k8s version check
    let mut github_server = mockito::Server::new_async().await;
    let _gm = github_server
        .mock("GET", "/repos/kubernetes/kubernetes/tags?per_page=100")
        .with_status(200)
        .with_header("content-type", "application/json")
        .with_body(r#"[{"name":"v1.35.0"}]"#)
        .create_async()
        .await;

    // ArtifactHub mock for metallb version check (check_outdated checks all deps)
    let mut ah_server = mockito::Server::new_async().await;
    let _am = ah_server
        .mock("GET", "/api/v1/packages/helm/metallb/metallb")
        .with_status(200)
        .with_header("content-type", "application/json")
        .with_body(r#"{"version":"0.14.0","available_versions":[]}"#)
        .create_async()
        .await;

    let dir = tempfile::tempdir().unwrap();
    let root = dir.path();
    std::fs::write(root.join("husako.toml"), K8S_METALLB_TOML).unwrap();

    // Cache for k8s regen after update
    write_release_cache(root, "1.35");
    // Cache for metallb (not updated but still needs chart schema during regen)
    write_artifacthub_chart_cache(root, "metallb/metallb", "0.15.3");

    husako_at(root)
        .args(["update", "--resources-only"])
        .env("HUSAKO_GITHUB_API_URL", github_server.url())
        .env("HUSAKO_ARTIFACTHUB_URL", ah_server.url())
        .assert()
        .success();

    let content = std::fs::read_to_string(root.join("husako.toml")).unwrap();
    assert!(content.contains("1.35"), "k8s should be updated to 1.35");
    assert!(
        content.contains("0.15.3"),
        "metallb version should remain 0.15.3"
    );
}

#[tokio::test]
async fn update_charts_only_skips_resources() {
    // GitHub API mock (check_outdated checks k8s even with --charts-only)
    let mut github_server = mockito::Server::new_async().await;
    let _gm = github_server
        .mock("GET", "/repos/kubernetes/kubernetes/tags?per_page=100")
        .with_status(200)
        .with_header("content-type", "application/json")
        .with_body(r#"[{"name":"v1.35.0"}]"#)
        .create_async()
        .await;

    // ArtifactHub mock returning newer version
    let mut ah_server = mockito::Server::new_async().await;
    let _am = ah_server
        .mock("GET", "/api/v1/packages/helm/metallb/metallb")
        .with_status(200)
        .with_header("content-type", "application/json")
        .with_body(r#"{"version":"0.15.3","available_versions":[]}"#)
        .create_async()
        .await;

    let dir = tempfile::tempdir().unwrap();
    let root = dir.path();
    std::fs::write(root.join("husako.toml"), K8S_METALLB_TOML).unwrap();

    // k8s stays at 1.35, metallb updated to 0.15.3
    write_release_cache(root, "1.35");
    write_artifacthub_chart_cache(root, "metallb/metallb", "0.15.3");

    husako_at(root)
        .args(["update", "--charts-only"])
        .env("HUSAKO_GITHUB_API_URL", github_server.url())
        .env("HUSAKO_ARTIFACTHUB_URL", ah_server.url())
        .assert()
        .success();

    let content = std::fs::read_to_string(root.join("husako.toml")).unwrap();
    // k8s version unchanged (still 1.35 as originally set in K8S_METALLB_TOML)
    assert!(content.contains("1.35"), "k8s version should be unchanged");
    // metallb should now be 0.15.3 (was already 0.15.3 in K8S_METALLB_TOML  just confirm not 0.14.0)
    assert!(
        !content.contains("0.14.0"),
        "metallb should not be downgraded"
    );
}

#[tokio::test]
async fn update_all_current_no_changes() {
    let mut server = mockito::Server::new_async().await;
    let _m = server
        .mock("GET", "/repos/kubernetes/kubernetes/tags?per_page=100")
        .with_status(200)
        .with_header("content-type", "application/json")
        .with_body(r#"[{"name":"v1.35.0"}]"#)
        .create_async()
        .await;

    let dir = tempfile::tempdir().unwrap();
    let root = dir.path();
    std::fs::write(
        root.join("husako.toml"),
        "[resources]\nk8s = { source = \"release\", version = \"1.35\" }\n",
    )
    .unwrap();

    husako_at(root)
        .args(["update"])
        .env("HUSAKO_GITHUB_API_URL", server.url())
        .assert()
        .success()
        .stderr(predicates::str::contains("up to date"));
}

#[tokio::test]
async fn add_artifacthub_chart_writes_toml() {
    let mut server = mockito::Server::new_async().await;
    // discover_latest_artifacthub fetches /api/v1/packages/helm/{package}
    let _m = server
        .mock("GET", "/api/v1/packages/helm/metallb/metallb")
        .with_status(200)
        .with_header("content-type", "application/json")
        .with_body(r#"{"version":"0.15.3","available_versions":[]}"#)
        .create_async()
        .await;

    let dir = tempfile::tempdir().unwrap();
    let root = dir.path();
    std::fs::write(root.join("husako.toml"), "").unwrap();

    // Pre-seed chart cache for auto-regen triggered after add
    write_artifacthub_chart_cache(root, "metallb/metallb", "0.15.3");

    husako_at(root)
        .args(["add", "metallb/metallb", "--name", "metallb"])
        .env("HUSAKO_ARTIFACTHUB_URL", server.url())
        .assert()
        .success()
        .stderr(predicates::str::contains("Added metallb"));

    let content = std::fs::read_to_string(root.join("husako.toml")).unwrap();
    assert!(
        content.contains("metallb"),
        "husako.toml should contain metallb entry"
    );
}

#[tokio::test]
async fn add_release_resource_writes_toml() {
    // --release provides version directly  no GitHub network call for discovery.
    // But run_auto_generate fires after add  needs release cache.
    let dir = tempfile::tempdir().unwrap();
    let root = dir.path();
    std::fs::write(root.join("husako.toml"), "").unwrap();

    write_release_cache(root, "1.35");

    husako_at(root)
        .args(["add", "--release", "1.35", "--name", "k8s"])
        .assert()
        .success()
        .stderr(predicates::str::contains("Added k8s"));

    let content = std::fs::read_to_string(root.join("husako.toml")).unwrap();
    assert!(
        content.contains("k8s"),
        "husako.toml should contain k8s entry"
    );
    assert!(
        content.contains("1.35"),
        "husako.toml should contain version 1.35"
    );
}

#[tokio::test]
async fn add_duplicate_chart_shows_message() {
    // ArtifactHub is called by discover_latest_artifacthub before the duplicate check
    let mut server = mockito::Server::new_async().await;
    let _m = server
        .mock("GET", "/api/v1/packages/helm/metallb/metallb")
        .with_status(200)
        .with_header("content-type", "application/json")
        .with_body(r#"{"version":"0.15.3","available_versions":[]}"#)
        .create_async()
        .await;

    let dir = tempfile::tempdir().unwrap();
    let root = dir.path();
    std::fs::write(
        root.join("husako.toml"),
        "[charts]\nmetallb = { source = \"artifacthub\", package = \"metallb/metallb\", version = \"0.15.3\" }\n",
    )
    .unwrap();

    husako_at(root)
        .args(["add", "metallb/metallb", "--name", "metallb"])
        .env("HUSAKO_ARTIFACTHUB_URL", server.url())
        .assert()
        .success()
        .stderr(predicates::str::contains("already in"));

    // toml unchanged
    let content = std::fs::read_to_string(root.join("husako.toml")).unwrap();
    assert!(content.contains("0.15.3"), "version should be unchanged");
}

// ---------------------------------------------------------------------------
// TypeScript type-check integration tests (husako check --type-check)
// ---------------------------------------------------------------------------

/// Write both `.js` runtime modules and post-fix `.d.ts` type declarations, plus
/// a `tsconfig.json` with the correct path mappings. Returns (tempdir, entry_path).
///
/// The `.d.ts` files reflect the post-fix generated types:
/// - No raw interface for GVK schemas (Deployment)  only the builder class
/// - No raw interface for builder schemas (Container, LabelSelector, DeploymentSpec)
/// - `resources()` accepts `ResourceRequirements | ResourceRequirementsFragment`
fn project_with_typed_k8s(ts_content: &str) -> (tempfile::TempDir, std::path::PathBuf) {
    let dir = tempfile::tempdir().unwrap();
    let root = dir.path();

    // Write runtime JS modules (same as existing write_k8s_modules)
    write_k8s_modules(root);

    // Write post-fix d.ts files
    let types_k8s = root.join(".husako/types/k8s");
    std::fs::create_dir_all(types_k8s.join("apps")).unwrap();
    std::fs::create_dir_all(types_k8s.join("core")).unwrap();

    std::fs::write(
        types_k8s.join("_common.d.ts"),
        r#"// Auto-generated by husako. Do not edit.

import { _SchemaBuilder } from "husako/_base";

export interface ObjectMeta {
  name?: string;
  namespace?: string;
  labels?: Record<string, string>;
  annotations?: Record<string, string>;
}

export interface LabelSelectorRequirement {
  key: string;
  operator: string;
  values?: string[];
}

export interface LabelSelector extends _SchemaBuilder {
  matchExpressions(value: LabelSelectorRequirement[]): this;
  matchLabels(value: Record<string, string>): this;
}
export function LabelSelector(): LabelSelector;
"#,
    )
    .unwrap();

    std::fs::write(
        types_k8s.join("apps/v1.d.ts"),
        r#"// Auto-generated by husako. Do not edit.

import { _ResourceBuilder, _SchemaBuilder } from "husako/_base";

import { LabelSelector } from "k8s/_common";

export interface Deployment extends _ResourceBuilder {
  /** Set the resource specification. */
  spec(value: DeploymentSpec): this;
  replicas(value: number): this;
  selector(value: LabelSelector): this;
  /** Set pod containers (shortcut for template.spec.containers). */
  containers(value: any[]): this;
  /** Set pod init containers (shortcut for template.spec.initContainers). */
  initContainers(value: any[]): this;
}
export function Deployment(): Deployment;

export interface DeploymentSpec extends _SchemaBuilder {
  replicas(value: number): this;
  selector(value: LabelSelector): this;
}
export function DeploymentSpec(): DeploymentSpec;
"#,
    )
    .unwrap();

    std::fs::write(
        types_k8s.join("core/v1.d.ts"),
        r#"// Auto-generated by husako. Do not edit.

import { _SchemaBuilder } from "husako/_base";

export interface ResourceRequirements {
  limits?: Record<string, string>;
  requests?: Record<string, string>;
}

export interface Container extends _SchemaBuilder {
  name(value: string): this;
  image(value: string): this;
  resources(value: ResourceRequirements | import("husako").ResourceRequirementsFragment): this;
}
export function Container(): Container;
"#,
    )
    .unwrap();

    // Write husako SDK type stubs
    let types_husako = root.join(".husako/types");
    std::fs::create_dir_all(types_husako.join("husako")).unwrap();
    std::fs::write(types_husako.join("husako.d.ts"), husako_sdk::HUSAKO_DTS).unwrap();
    std::fs::write(
        types_husako.join("husako/_base.d.ts"),
        husako_sdk::HUSAKO_BASE_DTS,
    )
    .unwrap();

    // Write tsconfig.json with path mappings
    std::fs::write(
        root.join("tsconfig.json"),
        r#"{
  "compilerOptions": {
    "baseUrl": ".",
    "module": "ESNext",
    "moduleResolution": "bundler",
    "strict": true,
    "paths": {
      "husako": [".husako/types/husako.d.ts"],
      "husako/_base": [".husako/types/husako/_base.d.ts"],
      "k8s/*": [".husako/types/k8s/*"]
    }
  }
}"#,
    )
    .unwrap();

    let entry = root.join("entry.ts");
    std::fs::write(&entry, ts_content).unwrap();
    (dir, entry)
}

#[test]
fn check_sdk_template_type_safe() {
    let tsc_available = std::process::Command::new("tsc")
        .arg("--version")
        .output()
        .is_ok();
    assert!(
        tsc_available,
        "tsc must be installed to run this test (npm install -g typescript)"
    );

    let (_dir, entry) = project_with_typed_k8s(
        r#"import { Deployment } from "k8s/apps/v1";
import { Container } from "k8s/core/v1";
import { LabelSelector } from "k8s/_common";
import { metadata, cpu, memory, requests, limits, build } from "husako";

const nginx = Deployment()
  .metadata(metadata().name("nginx").namespace("default").label("app", "nginx"))
  .replicas(1)
  .selector(LabelSelector().matchLabels({ app: "nginx" }))
  .containers([
    Container()
      .name("nginx")
      .image("nginx:1.25")
      .resources(requests(cpu("250m").memory("128Mi")).limits(cpu("500m").memory("256Mi"))),
  ]);

build([nginx]);
"#,
    );

    husako_at(entry.parent().unwrap())
        .args(["check", "--type-check", entry.to_str().unwrap()])
        .assert()
        .success()
        .stderr(predicates::str::contains("TypeScript types OK"));
}
