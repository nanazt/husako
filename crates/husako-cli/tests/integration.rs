use std::io::Write;
use std::path::Path;

use assert_cmd::cargo::cargo_bin_cmd;
use tempfile::NamedTempFile;

fn husako() -> assert_cmd::Command {
    cargo_bin_cmd!("husako")
}

fn husako_at(dir: &std::path::Path) -> assert_cmd::Command {
    let mut cmd = cargo_bin_cmd!("husako");
    cmd.current_dir(dir);
    cmd
}

fn write_temp_ts(content: &str) -> NamedTempFile {
    let mut f = tempfile::Builder::new().suffix(".ts").tempfile().unwrap();
    f.write_all(content.as_bytes()).unwrap();
    f
}

/// Write generated k8s runtime JS modules into `.husako/types/k8s/` under `root`.
fn write_k8s_modules(root: &Path) {
    let apps_dir = root.join(".husako/types/k8s/apps");
    std::fs::create_dir_all(&apps_dir).unwrap();
    std::fs::write(
        apps_dir.join("v1.js"),
        r#"// Auto-generated by husako. Do not edit.

import { _ResourceBuilder } from "husako/_base";

export class Deployment extends _ResourceBuilder {
  constructor() { super("apps/v1", "Deployment"); }
  replicas(v) { return this._setSpec("replicas", v); }
  selector(v) { return this._setSpec("selector", v); }
  strategy(v) { return this._setSpec("strategy", v); }
  template(v) { return this._setSpec("template", v); }
  containers(v) { return this._setDeep("template.spec.containers", v); }
  initContainers(v) { return this._setDeep("template.spec.initContainers", v); }
}
export function deployment() { return new Deployment(); }

export class StatefulSet extends _ResourceBuilder {
  constructor() { super("apps/v1", "StatefulSet"); }
  replicas(v) { return this._setSpec("replicas", v); }
  selector(v) { return this._setSpec("selector", v); }
  template(v) { return this._setSpec("template", v); }
  containers(v) { return this._setDeep("template.spec.containers", v); }
  initContainers(v) { return this._setDeep("template.spec.initContainers", v); }
}
export function statefulSet() { return new StatefulSet(); }

export class DaemonSet extends _ResourceBuilder {
  constructor() { super("apps/v1", "DaemonSet"); }
  selector(v) { return this._setSpec("selector", v); }
  template(v) { return this._setSpec("template", v); }
  containers(v) { return this._setDeep("template.spec.containers", v); }
  initContainers(v) { return this._setDeep("template.spec.initContainers", v); }
}
export function daemonSet() { return new DaemonSet(); }
"#,
    )
    .unwrap();

    let core_dir = root.join(".husako/types/k8s/core");
    std::fs::create_dir_all(&core_dir).unwrap();
    std::fs::write(
        core_dir.join("v1.js"),
        r#"// Auto-generated by husako. Do not edit.

import { _ResourceBuilder, _SchemaBuilder } from "husako/_base";

export class Namespace extends _ResourceBuilder {
  constructor() { super("v1", "Namespace"); }
}
export function namespace() { return new Namespace(); }

export class Service extends _ResourceBuilder {
  constructor() { super("v1", "Service"); }
  selector(v) { return this._setSpec("selector", v); }
  ports(v) { return this._setSpec("ports", v); }
  type(v) { return this._setSpec("type", v); }
}
export function service() { return new Service(); }

export class ConfigMap extends _ResourceBuilder {
  constructor() { super("v1", "ConfigMap"); }
}
export function configMap() { return new ConfigMap(); }

export class Container extends _SchemaBuilder {
  name(v) { return this._set("name", v); }
  image(v) { return this._set("image", v); }
  ports(v) { return this._set("ports", v); }
  resources(v) { return this._set("resources", v); }
  env(v) { return this._set("env", v); }
  command(v) { return this._set("command", v); }
  args(v) { return this._set("args", v); }
  volumeMounts(v) { return this._set("volumeMounts", v); }
}
export function container() { return new Container(); }

export class PodTemplateSpec extends _SchemaBuilder {
  metadata(v) { return this._set("metadata", v); }
  spec(v) { return this._set("spec", v); }
}
export function podTemplateSpec() { return new PodTemplateSpec(); }
export function podTemplate() { return new PodTemplateSpec(); }
"#,
    )
    .unwrap();

    // _common.js for common schema builders (LabelSelector, etc.)
    let common_dir = root.join(".husako/types/k8s");
    std::fs::write(
        common_dir.join("_common.js"),
        r#"// Auto-generated by husako. Do not edit.

import { _SchemaBuilder } from "husako/_base";

export class LabelSelector extends _SchemaBuilder {
  matchLabels(v) { return this._set("matchLabels", v); }
  matchExpressions(v) { return this._set("matchExpressions", v); }
}
export function labelSelector() { return new LabelSelector(); }
export { labelSelector as selector };
"#,
    )
    .unwrap();
}

/// Create a temp project dir with k8s modules, write the given TS content as entry.ts,
/// and return (tempdir, entry_path).
fn project_with_k8s(ts_content: &str) -> (tempfile::TempDir, std::path::PathBuf) {
    let dir = tempfile::tempdir().unwrap();
    let root = dir.path();
    write_k8s_modules(root);

    let entry = root.join("entry.ts");
    std::fs::write(&entry, ts_content).unwrap();
    (dir, entry)
}

#[test]
fn missing_build() {
    let f = write_temp_ts(r#"import { build } from "husako"; const x = 1;"#);
    husako()
        .args(["render", f.path().to_str().unwrap()])
        .assert()
        .code(7)
        .stderr(predicates::str::contains("build() was not called"));
}

#[test]
fn double_build() {
    let f = write_temp_ts(r#"import { build } from "husako"; build([]); build([]);"#);
    husako()
        .args(["render", f.path().to_str().unwrap()])
        .assert()
        .code(7)
        .stderr(predicates::str::contains("called 2 times"));
}

#[test]
fn strict_json_undefined() {
    let f = write_temp_ts(
        r#"import { build } from "husako"; build({ _render() { return { a: undefined }; } });"#,
    );
    husako()
        .args(["render", f.path().to_str().unwrap()])
        .assert()
        .code(7)
        .stderr(predicates::str::contains("undefined"));
}

#[test]
fn strict_json_function() {
    let f = write_temp_ts(
        r#"import { build } from "husako"; build({ _render() { return { fn: () => {} }; } });"#,
    );
    husako()
        .args(["render", f.path().to_str().unwrap()])
        .assert()
        .code(7)
        .stderr(predicates::str::contains("function"));
}

#[test]
fn compile_error() {
    let f = write_temp_ts("const = ;");
    husako()
        .args(["render", f.path().to_str().unwrap()])
        .assert()
        .code(3);
}

// --- Milestone 2: Module Loader + Project Imports ---

#[test]
fn render_project_imports() {
    let dir = tempfile::tempdir().unwrap();
    let root = dir.path();
    write_k8s_modules(root);

    // Replicate examples/project/ structure with builders
    std::fs::create_dir_all(root.join("lib")).unwrap();
    std::fs::write(
        root.join("lib/metadata.ts"),
        r#"import { metadata } from "husako";
export function appMetadata(appName: string) {
  return metadata().name(appName).label("app", appName);
}
"#,
    )
    .unwrap();
    std::fs::write(
        root.join("lib/index.ts"),
        r#"export { appMetadata } from "./metadata";"#,
    )
    .unwrap();

    std::fs::create_dir_all(root.join("deployments")).unwrap();
    std::fs::write(
        root.join("deployments/nginx.ts"),
        r#"import { deployment } from "k8s/apps/v1";
import { container } from "k8s/core/v1";
import { selector } from "k8s/_common";
import { appMetadata } from "../lib";
export const nginx = deployment()
  .metadata(appMetadata("nginx"))
  .replicas(1)
  .selector(selector().matchLabels({ app: "nginx" }))
  .containers([container().name("nginx").image("nginx:1.25")]);
"#,
    )
    .unwrap();

    std::fs::create_dir_all(root.join("env")).unwrap();
    let entry = root.join("env/dev.ts");
    std::fs::write(
        &entry,
        r#"import { build } from "husako";
import { nginx } from "../deployments/nginx";
build([nginx]);
"#,
    )
    .unwrap();

    husako_at(root)
        .args(["render", entry.to_str().unwrap()])
        .assert()
        .success()
        .stdout(predicates::str::contains("apiVersion: apps/v1"))
        .stdout(predicates::str::contains("kind: Deployment"))
        .stdout(predicates::str::contains("name: nginx"))
        .stdout(predicates::str::contains("app: nginx"));
}

#[test]
fn render_project_snapshot() {
    let dir = tempfile::tempdir().unwrap();
    let root = dir.path();
    write_k8s_modules(root);

    std::fs::create_dir_all(root.join("lib")).unwrap();
    std::fs::write(
        root.join("lib/metadata.ts"),
        r#"import { metadata } from "husako";
export function appMetadata(appName: string) {
  return metadata().name(appName).label("app", appName);
}
"#,
    )
    .unwrap();
    std::fs::write(
        root.join("lib/index.ts"),
        r#"export { appMetadata } from "./metadata";"#,
    )
    .unwrap();

    std::fs::create_dir_all(root.join("deployments")).unwrap();
    std::fs::write(
        root.join("deployments/nginx.ts"),
        r#"import { deployment } from "k8s/apps/v1";
import { container } from "k8s/core/v1";
import { selector } from "k8s/_common";
import { appMetadata } from "../lib";
export const nginx = deployment()
  .metadata(appMetadata("nginx"))
  .replicas(1)
  .selector(selector().matchLabels({ app: "nginx" }))
  .containers([container().name("nginx").image("nginx:1.25")]);
"#,
    )
    .unwrap();

    std::fs::create_dir_all(root.join("env")).unwrap();
    let entry = root.join("env/dev.ts");
    std::fs::write(
        &entry,
        r#"import { build } from "husako";
import { nginx } from "../deployments/nginx";
build([nginx]);
"#,
    )
    .unwrap();

    let output = husako_at(root)
        .args(["render", entry.to_str().unwrap()])
        .output()
        .unwrap();
    assert!(output.status.success());
    let yaml = String::from_utf8(output.stdout).unwrap();
    insta::assert_snapshot!(yaml);
}

#[test]
fn reject_outside_root() {
    let dir = tempfile::tempdir().unwrap();
    let root = dir.path();
    let sub = root.join("sub");
    std::fs::create_dir(&sub).unwrap();

    // Create a file outside the sub directory
    std::fs::write(root.join("secret.ts"), "export const x = 1;").unwrap();

    // Create entry file that imports outside root
    let entry = sub.join("entry.ts");
    std::fs::write(
        &entry,
        r#"import { build } from "husako"; import { x } from "../secret"; build([{ _render() { return { v: x }; } }]);"#,
    )
    .unwrap();

    // Run with cwd=sub so project_root=sub
    husako_at(&sub)
        .args(["render", entry.to_str().unwrap()])
        .assert()
        .code(4)
        .stderr(predicates::str::contains("outside project root"));
}

#[test]
fn allow_outside_root_flag() {
    let dir = tempfile::tempdir().unwrap();
    let root = dir.path();
    let sub = root.join("sub");
    std::fs::create_dir(&sub).unwrap();

    std::fs::write(root.join("outside.ts"), "export const val = 42;").unwrap();

    let entry = sub.join("entry.ts");
    std::fs::write(
        &entry,
        r#"import { build } from "husako"; import { val } from "../outside"; build([{ _render() { return { v: val }; } }]);"#,
    )
    .unwrap();

    // With --allow-outside-root, the boundary check is bypassed
    husako_at(&sub)
        .args(["render", "--allow-outside-root", entry.to_str().unwrap()])
        .assert()
        .success()
        .stdout(predicates::str::contains("v: 42"));
}

#[test]
fn extension_inference() {
    let dir = tempfile::tempdir().unwrap();
    let root = dir.path();

    // import "./lib" should resolve to lib.ts
    std::fs::write(root.join("lib.ts"), "export const x: number = 1;").unwrap();
    let entry = root.join("entry.ts");
    std::fs::write(
        &entry,
        r#"import { build } from "husako"; import { x } from "./lib"; build([{ _render() { return { v: x }; } }]);"#,
    )
    .unwrap();

    husako_at(root)
        .args(["render", entry.to_str().unwrap()])
        .assert()
        .success()
        .stdout(predicates::str::contains("v: 1"));
}

// --- Milestone 3: SDK Builders (now using generated k8s modules) ---

#[test]
fn render_canonical() {
    let (dir, entry) = project_with_k8s(
        r#"
import * as husako from "husako";
import { deployment } from "k8s/apps/v1";
import { name, namespace, label, cpu, memory, requests, limits } from "husako";

const nginx_metadata = name("nginx")
  .namespace("nginx-ns")
  .label("key1", "value1")
  .label("key2", "value2");

const another_labels_1 = label("key3", "value3").label("key4", "value4");
const another_labels_2 = label("key5", "value5").label("key6", "value6");

const nginx = deployment()
  .metadata(husako.merge([nginx_metadata, another_labels_1, another_labels_2]))
  .resources(
    requests(cpu(1).memory("2Gi")).limits(cpu("500m").memory(1))
  );

husako.build([nginx]);
"#,
    );
    husako_at(dir.path())
        .args(["render", entry.to_str().unwrap()])
        .assert()
        .success()
        .stdout(predicates::str::contains("apiVersion: apps/v1"))
        .stdout(predicates::str::contains("kind: Deployment"))
        .stdout(predicates::str::contains("name: nginx"))
        .stdout(predicates::str::contains("namespace: nginx-ns"))
        .stdout(predicates::str::contains("key1: value1"))
        .stdout(predicates::str::contains("key5: value5"))
        .stdout(predicates::str::contains("cpu: '1'"))
        .stdout(predicates::str::contains("memory: 2Gi"))
        .stdout(predicates::str::contains("cpu: 500m"))
        .stdout(predicates::str::contains("memory: 1Gi"));
}

#[test]
fn render_canonical_snapshot() {
    let (dir, entry) = project_with_k8s(
        r#"
import * as husako from "husako";
import { deployment } from "k8s/apps/v1";
import { name, namespace, label, cpu, memory, requests, limits } from "husako";

const nginx_metadata = name("nginx")
  .namespace("nginx-ns")
  .label("key1", "value1")
  .label("key2", "value2");

const another_labels_1 = label("key3", "value3").label("key4", "value4");
const another_labels_2 = label("key5", "value5").label("key6", "value6");

const nginx = deployment()
  .metadata(husako.merge([nginx_metadata, another_labels_1, another_labels_2]))
  .resources(
    requests(cpu(1).memory("2Gi")).limits(cpu("500m").memory(1))
  );

husako.build([nginx]);
"#,
    );
    let output = husako_at(dir.path())
        .args(["render", entry.to_str().unwrap()])
        .output()
        .unwrap();
    assert!(output.status.success());
    let yaml = String::from_utf8(output.stdout).unwrap();
    insta::assert_snapshot!(yaml);
}

#[test]
fn metadata_fragment_reuse() {
    let (dir, entry) = project_with_k8s(
        r#"
import { build, label } from "husako";
import { deployment } from "k8s/apps/v1";
const base = label("env", "dev");
const a = base.label("team", "a");
const b = base.label("team", "b");
const da = deployment().metadata(a);
const db = deployment().metadata(b);
build([da, db]);
"#,
    );
    let output = husako_at(dir.path())
        .args(["render", entry.to_str().unwrap()])
        .output()
        .unwrap();
    assert!(output.status.success());
    let yaml = String::from_utf8(output.stdout).unwrap();
    // Both should have env: dev
    assert_eq!(yaml.matches("env: dev").count(), 2);
    // a should have team: a, b should have team: b
    assert!(yaml.contains("team: a"));
    assert!(yaml.contains("team: b"));
}

#[test]
fn merge_labels_deep() {
    let (dir, entry) = project_with_k8s(
        r#"
import { build, name, label, merge } from "husako";
import { deployment } from "k8s/apps/v1";
const m = merge([name("test"), label("a", "1"), label("b", "2"), label("c", "3")]);
const d = deployment().metadata(m);
build([d]);
"#,
    );
    husako_at(dir.path())
        .args(["render", entry.to_str().unwrap()])
        .assert()
        .success()
        .stdout(predicates::str::contains("name: test"))
        .stdout(predicates::str::contains("a: '1'"))
        .stdout(predicates::str::contains("b: '2'"))
        .stdout(predicates::str::contains("c: '3'"));
}

#[test]
fn cpu_normalization() {
    let (dir, entry) = project_with_k8s(
        r#"
import { build, cpu, requests } from "husako";
import { deployment } from "k8s/apps/v1";
const d = deployment().resources(requests(cpu(0.5)));
build([d]);
"#,
    );
    husako_at(dir.path())
        .args(["render", entry.to_str().unwrap()])
        .assert()
        .success()
        .stdout(predicates::str::contains("cpu: 500m"));
}

#[test]
fn memory_normalization() {
    let (dir, entry) = project_with_k8s(
        r#"
import { build, memory, requests } from "husako";
import { deployment } from "k8s/apps/v1";
const d = deployment().resources(requests(memory(4)));
build([d]);
"#,
    );
    husako_at(dir.path())
        .args(["render", entry.to_str().unwrap()])
        .assert()
        .success()
        .stdout(predicates::str::contains("memory: 4Gi"));
}

#[test]
fn k8s_core_v1_namespace() {
    let (dir, entry) = project_with_k8s(
        r#"
import { build, name } from "husako";
import { namespace } from "k8s/core/v1";
const ns = namespace().metadata(name("my-ns"));
build([ns]);
"#,
    );
    husako_at(dir.path())
        .args(["render", entry.to_str().unwrap()])
        .assert()
        .success()
        .stdout(predicates::str::contains("apiVersion: v1"))
        .stdout(predicates::str::contains("kind: Namespace"))
        .stdout(predicates::str::contains("name: my-ns"));
}

#[test]
fn index_inference() {
    let dir = tempfile::tempdir().unwrap();
    let root = dir.path();

    // import "./lib" should resolve to lib/index.ts
    let lib = root.join("lib");
    std::fs::create_dir(&lib).unwrap();
    std::fs::write(lib.join("index.ts"), "export const x: number = 99;").unwrap();

    let entry = root.join("entry.ts");
    std::fs::write(
        &entry,
        r#"import { build } from "husako"; import { x } from "./lib"; build([{ _render() { return { v: x }; } }]);"#,
    )
    .unwrap();

    husako_at(root)
        .args(["render", entry.to_str().unwrap()])
        .assert()
        .success()
        .stdout(predicates::str::contains("v: 99"));
}

// --- Milestone 6: Schema-aware Quantity Validation ---

#[test]
fn invalid_quantity_fallback_exit_7() {
    let f = write_temp_ts(
        r#"
import { build } from "husako";
build([{ _render() { return {
    apiVersion: "apps/v1",
    kind: "Deployment",
    spec: {
        template: {
            spec: {
                containers: [{
                    resources: {
                        requests: { cpu: "2gb" }
                    }
                }]
            }
        }
    }
}; } }]);
"#,
    );
    husako()
        .args(["render", f.path().to_str().unwrap()])
        .assert()
        .code(7)
        .stderr(predicates::str::contains("invalid quantity"))
        .stderr(predicates::str::contains("2gb"));
}

#[test]
fn valid_quantities_exit_0() {
    let f = write_temp_ts(
        r#"
import { build } from "husako";
build([{ _render() { return {
    apiVersion: "apps/v1",
    kind: "Deployment",
    spec: {
        template: {
            spec: {
                containers: [{
                    resources: {
                        requests: { cpu: "500m", memory: "1Gi" },
                        limits: { cpu: "1", memory: "2Gi" }
                    }
                }]
            }
        }
    }
}; } }]);
"#,
    );
    husako()
        .args(["render", f.path().to_str().unwrap()])
        .assert()
        .success();
}

#[test]
fn numbers_at_quantity_positions_exit_0() {
    let f = write_temp_ts(
        r#"
import { build } from "husako";
build([{ _render() { return {
    apiVersion: "apps/v1",
    kind: "Deployment",
    spec: {
        template: {
            spec: {
                containers: [{
                    resources: {
                        requests: { cpu: 1, memory: 2 }
                    }
                }]
            }
        }
    }
}; } }]);
"#,
    );
    husako()
        .args(["render", f.path().to_str().unwrap()])
        .assert()
        .success();
}

// --- Milestone 5: Type Generation + husako generate ---

#[test]
fn generate_skip_k8s() {
    let dir = tempfile::tempdir().unwrap();
    let root = dir.path();

    husako_at(root)
        .args(["generate", "--skip-k8s"])
        .assert()
        .success();

    // Static .d.ts files should exist
    assert!(root.join(".husako/types/husako.d.ts").exists());
    assert!(root.join(".husako/types/husako/_base.d.ts").exists());

    // tsconfig.json should exist with husako paths
    let tsconfig = std::fs::read_to_string(root.join("tsconfig.json")).unwrap();
    let parsed: serde_json::Value = serde_json::from_str(&tsconfig).unwrap();
    assert!(parsed["compilerOptions"]["paths"]["husako"].is_array());
    assert!(parsed["compilerOptions"]["paths"]["k8s/*"].is_array());

    // No k8s/ directory since we skipped k8s types
    assert!(!root.join(".husako/types/k8s").exists());
}

fn write_mock_spec(dir: &Path, group_path: &str) {
    let spec = rich_mock_spec();
    let spec_path = dir.join(format!("{group_path}.json"));
    std::fs::create_dir_all(spec_path.parent().unwrap()).unwrap();
    std::fs::write(spec_path, spec.to_string()).unwrap();
}

fn rich_mock_spec() -> serde_json::Value {
    serde_json::json!({
        "components": {
            "schemas": {
                "io.k8s.api.apps.v1.Deployment": {
                    "description": "Deployment enables declarative updates.",
                    "properties": {
                        "apiVersion": {"type": "string"},
                        "kind": {"type": "string"},
                        "metadata": {"$ref": "#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"},
                        "spec": {"$ref": "#/components/schemas/io.k8s.api.apps.v1.DeploymentSpec"}
                    },
                    "x-kubernetes-group-version-kind": [
                        {"group": "apps", "version": "v1", "kind": "Deployment"}
                    ]
                },
                "io.k8s.api.apps.v1.DeploymentSpec": {
                    "properties": {
                        "replicas": {"type": "integer"},
                        "selector": {"$ref": "#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.LabelSelector"},
                        "strategy": {"$ref": "#/components/schemas/io.k8s.api.apps.v1.DeploymentStrategy"},
                        "template": {"$ref": "#/components/schemas/io.k8s.api.core.v1.PodTemplateSpec"}
                    },
                    "required": ["selector"]
                },
                "io.k8s.api.apps.v1.DeploymentStrategy": {
                    "properties": {
                        "type": {
                            "type": "string",
                            "enum": ["Recreate", "RollingUpdate"]
                        }
                    }
                },
                "io.k8s.api.core.v1.PodTemplateSpec": {
                    "properties": {
                        "spec": {"$ref": "#/components/schemas/io.k8s.api.core.v1.PodSpec"}
                    }
                },
                "io.k8s.api.core.v1.PodSpec": {
                    "properties": {
                        "containers": {
                            "type": "array",
                            "items": {"$ref": "#/components/schemas/io.k8s.api.core.v1.Container"}
                        }
                    }
                },
                "io.k8s.api.core.v1.Container": {
                    "properties": {
                        "name": {"type": "string"},
                        "imagePullPolicy": {
                            "type": "string",
                            "enum": ["Always", "IfNotPresent", "Never"]
                        },
                        "resources": {"$ref": "#/components/schemas/io.k8s.api.core.v1.ResourceRequirements"}
                    }
                },
                "io.k8s.api.core.v1.ResourceRequirements": {
                    "properties": {
                        "limits": {
                            "type": "object",
                            "additionalProperties": {"$ref": "#/components/schemas/io.k8s.apimachinery.pkg.api.resource.Quantity"}
                        },
                        "requests": {
                            "type": "object",
                            "additionalProperties": {"$ref": "#/components/schemas/io.k8s.apimachinery.pkg.api.resource.Quantity"}
                        }
                    }
                },
                "io.k8s.apimachinery.pkg.api.resource.Quantity": {
                    "description": "Quantity is a representation of a decimal number.",
                    "type": "string"
                },
                "io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta": {
                    "description": "Standard object metadata.",
                    "properties": {
                        "name": {"type": "string"},
                        "namespace": {"type": "string"}
                    }
                },
                "io.k8s.apimachinery.pkg.apis.meta.v1.LabelSelector": {
                    "properties": {
                        "matchLabels": {
                            "type": "object",
                            "additionalProperties": {"type": "string"}
                        }
                    }
                }
            }
        }
    })
}

/// Write a `_schema.json` at `.husako/types/k8s/_schema.json` using husako_dts.
fn write_schema_store(root: &Path) {
    let spec = rich_mock_spec();
    let specs = std::collections::HashMap::from([("apis/apps/v1".to_string(), spec)]);
    let store = husako_dts::schema_store::generate_schema_store(&specs);
    let json = serde_json::to_string_pretty(&store).unwrap();
    let schema_dir = root.join(".husako/types/k8s");
    std::fs::create_dir_all(&schema_dir).unwrap();
    std::fs::write(schema_dir.join("_schema.json"), json).unwrap();
}

#[test]
fn generate_spec_dir() {
    let dir = tempfile::tempdir().unwrap();
    let root = dir.path();

    // Create mock spec directory
    let spec_dir = root.join("specs");
    std::fs::create_dir_all(&spec_dir).unwrap();
    write_mock_spec(&spec_dir, "apis/apps/v1");

    husako_at(root)
        .args(["generate", "--spec-dir", spec_dir.to_str().unwrap()])
        .assert()
        .success();

    // Static .d.ts files should exist
    assert!(root.join(".husako/types/husako.d.ts").exists());
    assert!(root.join(".husako/types/husako/_base.d.ts").exists());

    // Generated k8s types should exist (.d.ts and .js)
    assert!(root.join(".husako/types/k8s/_common.d.ts").exists());
    assert!(root.join(".husako/types/k8s/apps/v1.d.ts").exists());
    assert!(root.join(".husako/types/k8s/apps/v1.js").exists());

    // .d.ts should contain Deployment builder
    let apps_v1 = std::fs::read_to_string(root.join(".husako/types/k8s/apps/v1.d.ts")).unwrap();
    assert!(apps_v1.contains("class Deployment"));
    assert!(apps_v1.contains("_ResourceBuilder"));

    // .js should contain Deployment class
    let apps_v1_js = std::fs::read_to_string(root.join(".husako/types/k8s/apps/v1.js")).unwrap();
    assert!(apps_v1_js.contains("class Deployment"));
    assert!(apps_v1_js.contains("\"apps/v1\""));

    // tsconfig.json should exist
    assert!(root.join("tsconfig.json").exists());
}

#[test]
fn generate_updates_existing_tsconfig() {
    let dir = tempfile::tempdir().unwrap();
    let root = dir.path();

    // Pre-create tsconfig.json with existing content
    let existing = serde_json::json!({
        "compilerOptions": {
            "strict": true,
            "target": "ES2020",
            "paths": {
                "mylib/*": ["./lib/*"]
            }
        },
        "include": ["src/**/*"]
    });
    std::fs::write(
        root.join("tsconfig.json"),
        serde_json::to_string_pretty(&existing).unwrap(),
    )
    .unwrap();

    husako_at(root)
        .args(["generate", "--skip-k8s"])
        .assert()
        .success();

    let tsconfig = std::fs::read_to_string(root.join("tsconfig.json")).unwrap();
    let parsed: serde_json::Value = serde_json::from_str(&tsconfig).unwrap();

    // Original fields preserved
    assert_eq!(parsed["compilerOptions"]["target"], "ES2020");
    assert!(parsed["include"].is_array());

    // Original path preserved
    assert!(parsed["compilerOptions"]["paths"]["mylib/*"].is_array());

    // husako paths added
    assert!(parsed["compilerOptions"]["paths"]["husako"].is_array());
    assert!(parsed["compilerOptions"]["paths"]["husako/_base"].is_array());
    assert!(parsed["compilerOptions"]["paths"]["k8s/*"].is_array());
}

// --- Milestone 7: Schema-based Validation ---

#[test]
fn schema_invalid_enum_exit_7() {
    let dir = tempfile::tempdir().unwrap();
    let root = dir.path();
    write_schema_store(root);

    let entry = root.join("entry.ts");
    std::fs::write(
        &entry,
        r#"
import { build } from "husako";
build([{ _render() { return {
    apiVersion: "apps/v1",
    kind: "Deployment",
    spec: {
        selector: {},
        strategy: { type: "bluegreen" }
    }
}; } }]);
"#,
    )
    .unwrap();

    husako_at(root)
        .args(["render", entry.to_str().unwrap()])
        .assert()
        .code(7)
        .stderr(predicates::str::contains("invalid value"))
        .stderr(predicates::str::contains("bluegreen"));
}

#[test]
fn schema_type_mismatch_exit_7() {
    let dir = tempfile::tempdir().unwrap();
    let root = dir.path();
    write_schema_store(root);

    let entry = root.join("entry.ts");
    std::fs::write(
        &entry,
        r#"
import { build } from "husako";
build([{ _render() { return {
    apiVersion: "apps/v1",
    kind: "Deployment",
    spec: {
        selector: {},
        replicas: "abc"
    }
}; } }]);
"#,
    )
    .unwrap();

    husako_at(root)
        .args(["render", entry.to_str().unwrap()])
        .assert()
        .code(7)
        .stderr(predicates::str::contains("expected type integer"));
}

#[test]
fn schema_missing_required_exit_7() {
    let dir = tempfile::tempdir().unwrap();
    let root = dir.path();
    write_schema_store(root);

    let entry = root.join("entry.ts");
    std::fs::write(
        &entry,
        r#"
import { build } from "husako";
build([{ _render() { return {
    apiVersion: "apps/v1",
    kind: "Deployment",
    spec: {
        replicas: 3
    }
}; } }]);
"#,
    )
    .unwrap();

    husako_at(root)
        .args(["render", entry.to_str().unwrap()])
        .assert()
        .code(7)
        .stderr(predicates::str::contains("missing required field"));
}

#[test]
fn schema_valid_passes() {
    let dir = tempfile::tempdir().unwrap();
    let root = dir.path();
    write_schema_store(root);

    let entry = root.join("entry.ts");
    std::fs::write(
        &entry,
        r#"
import { build } from "husako";
build([{ _render() { return {
    apiVersion: "apps/v1",
    kind: "Deployment",
    spec: {
        selector: { matchLabels: { app: "test" } },
        replicas: 3,
        strategy: { type: "RollingUpdate" },
        template: {
            spec: {
                containers: [{
                    name: "main",
                    imagePullPolicy: "Always",
                    resources: {
                        requests: { cpu: "500m", memory: "1Gi" },
                        limits: { cpu: "1", memory: "2Gi" }
                    }
                }]
            }
        }
    }
}; } }]);
"#,
    )
    .unwrap();

    husako_at(root)
        .args(["render", entry.to_str().unwrap()])
        .assert()
        .success();
}

#[test]
fn schema_invalid_quantity_exit_7() {
    let dir = tempfile::tempdir().unwrap();
    let root = dir.path();
    write_schema_store(root);

    let entry = root.join("entry.ts");
    std::fs::write(
        &entry,
        r#"
import { build } from "husako";
build([{ _render() { return {
    apiVersion: "apps/v1",
    kind: "Deployment",
    spec: {
        selector: {},
        template: {
            spec: {
                containers: [{
                    resources: {
                        requests: { cpu: "2gb" }
                    }
                }]
            }
        }
    }
}; } }]);
"#,
    )
    .unwrap();

    husako_at(root)
        .args(["render", entry.to_str().unwrap()])
        .assert()
        .code(7)
        .stderr(predicates::str::contains("invalid quantity"))
        .stderr(predicates::str::contains("2gb"));
}

// --- Milestone 8: Safety & Diagnostics ---

#[test]
fn timeout_infinite_loop_exit_4() {
    let f = write_temp_ts(
        r#"
import { build } from "husako";
while(true) {}
build([]);
"#,
    );
    husako()
        .args(["render", "--timeout-ms", "100", f.path().to_str().unwrap()])
        .assert()
        .code(4)
        .stderr(predicates::str::contains("timed out"));
}

#[test]
fn memory_limit_exit_4() {
    let f = write_temp_ts(
        r#"
import { build } from "husako";
const arr = [];
for (let i = 0; i < 10000000; i++) { arr.push(new Array(1000)); }
build([]);
"#,
    );
    husako()
        .args(["render", "--max-heap-mb", "1", f.path().to_str().unwrap()])
        .assert()
        .code(4)
        .stderr(predicates::str::contains("memory limit"));
}

#[test]
fn timeout_does_not_interfere_with_normal_script() {
    let f = write_temp_ts(
        r#"
import { build } from "husako";
build([{ _render() { return { apiVersion: "v1", kind: "Namespace", metadata: { name: "test" } }; } }]);
"#,
    );
    husako()
        .args(["render", "--timeout-ms", "5000", f.path().to_str().unwrap()])
        .assert()
        .success()
        .stdout(predicates::str::contains("kind: Namespace"));
}

#[test]
fn verbose_produces_stderr_output() {
    let f = write_temp_ts(
        r#"
import { build } from "husako";
build([{ _render() { return { apiVersion: "v1", kind: "Namespace", metadata: { name: "test" } }; } }]);
"#,
    );
    husako()
        .args(["render", "--verbose", f.path().to_str().unwrap()])
        .assert()
        .success()
        .stderr(predicates::str::contains("[compile]"))
        .stderr(predicates::str::contains("[execute]"))
        .stderr(predicates::str::contains("[validate]"))
        .stderr(predicates::str::contains("[emit]"));
}

#[test]
fn generate_creates_schema_json() {
    let dir = tempfile::tempdir().unwrap();
    let root = dir.path();

    let spec_dir = root.join("specs");
    std::fs::create_dir_all(&spec_dir).unwrap();
    write_mock_spec(&spec_dir, "apis/apps/v1");

    husako_at(root)
        .args(["generate", "--spec-dir", spec_dir.to_str().unwrap()])
        .assert()
        .success();

    // _schema.json should exist (replaces _validation.json)
    assert!(root.join(".husako/types/k8s/_schema.json").exists());

    // Check basic structure
    let content = std::fs::read_to_string(root.join(".husako/types/k8s/_schema.json")).unwrap();
    let parsed: serde_json::Value = serde_json::from_str(&content).unwrap();
    assert_eq!(parsed["version"], 2);
    assert!(parsed["gvk_index"].is_object());
    assert!(parsed["schemas"].is_object());
}

// --- husako new ---

#[test]
fn new_simple_creates_project() {
    let dir = tempfile::tempdir().unwrap();
    let target = dir.path().join("my-app");

    husako()
        .args(["new", target.to_str().unwrap()])
        .assert()
        .success()
        .stderr(predicates::str::contains("Created 'simple' project"))
        .stderr(predicates::str::contains("husako generate"));

    assert!(target.join(".gitignore").exists());
    assert!(target.join("husako.toml").exists());
    assert!(target.join("entry.ts").exists());
}

#[test]
fn new_project_template() {
    let dir = tempfile::tempdir().unwrap();
    let target = dir.path().join("my-app");

    husako()
        .args(["new", "--template", "project", target.to_str().unwrap()])
        .assert()
        .success()
        .stderr(predicates::str::contains("Created 'project' project"));

    assert!(target.join(".gitignore").exists());
    assert!(target.join("husako.toml").exists());
    assert!(target.join("env/dev.ts").exists());
    assert!(target.join("deployments/nginx.ts").exists());
    assert!(target.join("lib/index.ts").exists());
    assert!(target.join("lib/metadata.ts").exists());
}

#[test]
fn new_multi_env_template() {
    let dir = tempfile::tempdir().unwrap();
    let target = dir.path().join("my-app");

    husako()
        .args(["new", "--template", "multi-env", target.to_str().unwrap()])
        .assert()
        .success()
        .stderr(predicates::str::contains("Created 'multi-env' project"));

    assert!(target.join(".gitignore").exists());
    assert!(target.join("husako.toml").exists());
    assert!(target.join("base/nginx.ts").exists());
    assert!(target.join("base/service.ts").exists());
    assert!(target.join("dev/main.ts").exists());
    assert!(target.join("staging/main.ts").exists());
    assert!(target.join("release/main.ts").exists());
}

#[test]
fn new_rejects_nonempty_dir() {
    let dir = tempfile::tempdir().unwrap();
    let target = dir.path().join("my-app");
    std::fs::create_dir_all(&target).unwrap();
    std::fs::write(target.join("existing.txt"), "content").unwrap();

    husako()
        .args(["new", target.to_str().unwrap()])
        .assert()
        .code(1)
        .stderr(predicates::str::contains("not empty"));
}

#[test]
fn new_then_render_simple() {
    let dir = tempfile::tempdir().unwrap();
    let target = dir.path().join("my-app");

    // Scaffold
    husako()
        .args(["new", target.to_str().unwrap()])
        .assert()
        .success();

    // Write k8s modules for rendering
    write_k8s_modules(&target);

    // Render
    husako_at(&target)
        .args(["render", target.join("entry.ts").to_str().unwrap()])
        .assert()
        .success()
        .stdout(predicates::str::contains("apiVersion: apps/v1"))
        .stdout(predicates::str::contains("kind: Deployment"))
        .stdout(predicates::str::contains("name: nginx"));
}

#[test]
fn new_then_render_project() {
    let dir = tempfile::tempdir().unwrap();
    let target = dir.path().join("my-app");

    // Scaffold
    husako()
        .args(["new", "--template", "project", target.to_str().unwrap()])
        .assert()
        .success();

    // Write k8s modules for rendering
    write_k8s_modules(&target);

    // Render
    husako_at(&target)
        .args(["render", target.join("env/dev.ts").to_str().unwrap()])
        .assert()
        .success()
        .stdout(predicates::str::contains("apiVersion: apps/v1"))
        .stdout(predicates::str::contains("kind: Deployment"))
        .stdout(predicates::str::contains("name: nginx"));
}

#[test]
fn new_then_render_multi_env() {
    let dir = tempfile::tempdir().unwrap();
    let target = dir.path().join("my-app");

    // Scaffold
    husako()
        .args(["new", "--template", "multi-env", target.to_str().unwrap()])
        .assert()
        .success();

    // Write k8s modules for rendering
    write_k8s_modules(&target);

    // Render dev
    let dev_output = husako_at(&target)
        .args(["render", target.join("dev/main.ts").to_str().unwrap()])
        .output()
        .unwrap();
    assert!(dev_output.status.success());
    let dev_yaml = String::from_utf8(dev_output.stdout).unwrap();
    assert!(dev_yaml.contains("namespace: dev"));
    assert!(dev_yaml.contains("replicas: 1"));
    assert!(dev_yaml.contains("image: nginx:latest"));

    // Render release
    let release_output = husako_at(&target)
        .args(["render", target.join("release/main.ts").to_str().unwrap()])
        .output()
        .unwrap();
    assert!(release_output.status.success());
    let release_yaml = String::from_utf8(release_output.stdout).unwrap();
    assert!(release_yaml.contains("namespace: release"));
    assert!(release_yaml.contains("replicas: 3"));
    assert!(release_yaml.contains("image: nginx:1.25"));
}

// --- Milestone 8 (Dynamic K8s Resources): New tests ---

#[test]
fn render_k8s_import_without_generate() {
    let dir = tempfile::tempdir().unwrap();
    let root = dir.path();

    let entry = root.join("entry.ts");
    std::fs::write(
        &entry,
        r#"
import { build } from "husako";
import { deployment } from "k8s/apps/v1";
build([deployment()]);
"#,
    )
    .unwrap();

    husako_at(root)
        .args(["render", entry.to_str().unwrap()])
        .assert()
        .code(4)
        .stderr(predicates::str::contains("husako generate"));
}

#[test]
fn generate_creates_js_modules() {
    let dir = tempfile::tempdir().unwrap();
    let root = dir.path();

    let spec_dir = root.join("specs");
    std::fs::create_dir_all(&spec_dir).unwrap();
    write_mock_spec(&spec_dir, "apis/apps/v1");

    husako_at(root)
        .args(["generate", "--spec-dir", spec_dir.to_str().unwrap()])
        .assert()
        .success();

    // .js should exist alongside .d.ts
    assert!(root.join(".husako/types/k8s/apps/v1.js").exists());

    let js = std::fs::read_to_string(root.join(".husako/types/k8s/apps/v1.js")).unwrap();
    assert!(js.contains("class Deployment"));
    assert!(js.contains("_ResourceBuilder"));
}

#[test]
fn render_with_generated_modules() {
    let dir = tempfile::tempdir().unwrap();
    let root = dir.path();

    // Generate via husako generate
    let spec_dir = root.join("specs");
    std::fs::create_dir_all(&spec_dir).unwrap();
    write_mock_spec(&spec_dir, "apis/apps/v1");

    husako_at(root)
        .args(["generate", "--spec-dir", spec_dir.to_str().unwrap()])
        .assert()
        .success();

    // Now render using generated modules
    let entry = root.join("entry.ts");
    std::fs::write(
        &entry,
        r#"
import { build, name } from "husako";
import { deployment } from "k8s/apps/v1";
const d = deployment().metadata(name("test"));
build([d]);
"#,
    )
    .unwrap();

    husako_at(root)
        .args(["render", entry.to_str().unwrap()])
        .assert()
        .success()
        .stdout(predicates::str::contains("apiVersion: apps/v1"))
        .stdout(predicates::str::contains("kind: Deployment"))
        .stdout(predicates::str::contains("name: test"));
}

#[test]
fn generic_spec_setter() {
    let (dir, entry) = project_with_k8s(
        r#"
import { build, name } from "husako";
import { namespace } from "k8s/core/v1";
const ns = namespace()
    .metadata(name("my-ns"))
    .spec({ finalizers: ["kubernetes"] });
build([ns]);
"#,
    );
    husako_at(dir.path())
        .args(["render", entry.to_str().unwrap()])
        .assert()
        .success()
        .stdout(predicates::str::contains("kind: Namespace"))
        .stdout(predicates::str::contains("name: my-ns"))
        .stdout(predicates::str::contains("finalizers"));
}

#[test]
fn generic_set_configmap() {
    let (dir, entry) = project_with_k8s(
        r#"
import { build, name } from "husako";
import { configMap } from "k8s/core/v1";
const cm = configMap()
    .metadata(name("my-config"))
    .set("data", { key1: "val1", key2: "val2" });
build([cm]);
"#,
    );
    husako_at(dir.path())
        .args(["render", entry.to_str().unwrap()])
        .assert()
        .success()
        .stdout(predicates::str::contains("kind: ConfigMap"))
        .stdout(predicates::str::contains("key1: val1"))
        .stdout(predicates::str::contains("key2: val2"));
}

// --- Generic Builder Pattern ---

#[test]
fn builder_spec_property_methods() {
    let (dir, entry) = project_with_k8s(
        r#"
import { build, metadata } from "husako";
import { deployment } from "k8s/apps/v1";
import { container } from "k8s/core/v1";
import { selector } from "k8s/_common";
const d = deployment()
    .metadata(metadata().name("nginx").label("app", "nginx"))
    .replicas(3)
    .selector(selector().matchLabels({ app: "nginx" }))
    .containers([
        container().name("nginx").image("nginx:1.25")
    ]);
build([d]);
"#,
    );
    husako_at(dir.path())
        .args(["render", entry.to_str().unwrap()])
        .assert()
        .success()
        .stdout(predicates::str::contains("apiVersion: apps/v1"))
        .stdout(predicates::str::contains("kind: Deployment"))
        .stdout(predicates::str::contains("name: nginx"))
        .stdout(predicates::str::contains("replicas: 3"))
        .stdout(predicates::str::contains("app: nginx"))
        .stdout(predicates::str::contains("image: nginx:1.25"));
}

#[test]
fn builder_set_deep_merges() {
    let (dir, entry) = project_with_k8s(
        r#"
import { build, name } from "husako";
import { deployment } from "k8s/apps/v1";
import { container } from "k8s/core/v1";
const d = deployment()
    .metadata(name("nginx"))
    .replicas(2)
    .containers([container().name("nginx").image("nginx:1.25")])
    .initContainers([container().name("init").image("busybox")]);
build([d]);
"#,
    );
    let output = husako_at(dir.path())
        .args(["render", entry.to_str().unwrap()])
        .output()
        .unwrap();
    assert!(output.status.success());
    let yaml = String::from_utf8(output.stdout).unwrap();
    // Both containers and initContainers should exist under template.spec
    assert!(yaml.contains("name: nginx"));
    assert!(yaml.contains("image: nginx:1.25"));
    assert!(yaml.contains("name: init"));
    assert!(yaml.contains("image: busybox"));
    assert!(yaml.contains("replicas: 2"));
}

#[test]
fn builder_spec_overrides_spec_parts() {
    let (dir, entry) = project_with_k8s(
        r#"
import { build, name } from "husako";
import { deployment } from "k8s/apps/v1";
// .spec() should override any _specParts set via .replicas()
const d = deployment()
    .metadata(name("nginx"))
    .replicas(3)
    .spec({ replicas: 5, selector: {} });
build([d]);
"#,
    );
    let output = husako_at(dir.path())
        .args(["render", entry.to_str().unwrap()])
        .output()
        .unwrap();
    assert!(output.status.success());
    let yaml = String::from_utf8(output.stdout).unwrap();
    // .spec() wins over .replicas()
    assert!(yaml.contains("replicas: 5"));
    assert!(!yaml.contains("replicas: 3"));
}

#[test]
fn builder_spec_parts_and_resources_merge() {
    let (dir, entry) = project_with_k8s(
        r#"
import { build, name, cpu, memory, requests, limits } from "husako";
import { deployment } from "k8s/apps/v1";
import { container } from "k8s/core/v1";
import { selector } from "k8s/_common";
// _specParts (from .replicas/.containers) and _resources should merge
const d = deployment()
    .metadata(name("nginx"))
    .replicas(2)
    .selector(selector().matchLabels({ app: "nginx" }))
    .containers([
        container().name("nginx").image("nginx:1.25")
            .resources(requests(cpu("250m").memory("128Mi")).limits(cpu("500m").memory("256Mi")))
    ]);
build([d]);
"#,
    );
    let output = husako_at(dir.path())
        .args(["render", entry.to_str().unwrap()])
        .output()
        .unwrap();
    assert!(output.status.success());
    let yaml = String::from_utf8(output.stdout).unwrap();
    // Both specParts and resources should be present
    assert!(yaml.contains("replicas: 2"));
    assert!(yaml.contains("image: nginx:1.25"));
    assert!(yaml.contains("cpu: 250m"));
    assert!(yaml.contains("memory: 128Mi"));
    assert!(yaml.contains("cpu: 500m"));
    assert!(yaml.contains("memory: 256Mi"));
}

#[test]
fn builder_copy_on_write_isolation() {
    let (dir, entry) = project_with_k8s(
        r#"
import { build, name } from "husako";
import { deployment } from "k8s/apps/v1";
const base = deployment().metadata(name("base")).replicas(1);
const a = base.replicas(3);
const b = base.replicas(5);
build([a, b]);
"#,
    );
    let output = husako_at(dir.path())
        .args(["render", entry.to_str().unwrap()])
        .output()
        .unwrap();
    assert!(output.status.success());
    let yaml = String::from_utf8(output.stdout).unwrap();
    assert!(yaml.contains("replicas: 3"));
    assert!(yaml.contains("replicas: 5"));
    // base's replicas=1 should not appear
    assert!(!yaml.contains("replicas: 1"));
}

#[test]
fn builder_service_spec_properties() {
    let (dir, entry) = project_with_k8s(
        r#"
import { build, name } from "husako";
import { service } from "k8s/core/v1";
const svc = service()
    .metadata(name("nginx"))
    .selector({ app: "nginx" })
    .ports([{ port: 80, targetPort: 8080 }])
    .type("ClusterIP");
build([svc]);
"#,
    );
    husako_at(dir.path())
        .args(["render", entry.to_str().unwrap()])
        .assert()
        .success()
        .stdout(predicates::str::contains("kind: Service"))
        .stdout(predicates::str::contains("app: nginx"))
        .stdout(predicates::str::contains("port: 80"))
        .stdout(predicates::str::contains("targetPort: 8080"))
        .stdout(predicates::str::contains("type: ClusterIP"));
}

// --- husako.toml entry aliases ---

#[test]
fn render_with_entry_alias() {
    let dir = tempfile::tempdir().unwrap();
    let root = dir.path();

    // Create husako.toml with an entry alias
    std::fs::write(
        root.join("husako.toml"),
        r#"
[entries]
dev = "env/dev.ts"

[schemas]
kubernetes = { source = "release", version = "1.35" }
"#,
    )
    .unwrap();

    // Create the entry file
    std::fs::create_dir_all(root.join("env")).unwrap();
    std::fs::write(
        root.join("env/dev.ts"),
        r#"
import { build } from "husako";
build([{ _render() { return { apiVersion: "v1", kind: "Namespace", metadata: { name: "dev" } }; } }]);
"#,
    )
    .unwrap();

    // Render using alias
    husako_at(root)
        .args(["render", "dev"])
        .assert()
        .success()
        .stdout(predicates::str::contains("kind: Namespace"))
        .stdout(predicates::str::contains("name: dev"));
}

#[test]
fn render_alias_file_not_found() {
    let dir = tempfile::tempdir().unwrap();
    let root = dir.path();

    std::fs::write(
        root.join("husako.toml"),
        r#"
[entries]
dev = "env/dev.ts"
"#,
    )
    .unwrap();

    // File doesn't exist  should show which file the alias maps to
    husako_at(root)
        .args(["render", "dev"])
        .assert()
        .code(2)
        .stderr(predicates::str::contains("env/dev.ts"))
        .stderr(predicates::str::contains("not found"));
}

#[test]
fn render_unknown_alias_lists_available() {
    let dir = tempfile::tempdir().unwrap();
    let root = dir.path();

    std::fs::write(
        root.join("husako.toml"),
        r#"
[entries]
dev = "env/dev.ts"
staging = "env/staging.ts"
"#,
    )
    .unwrap();

    // Unknown alias  should list available aliases
    husako_at(root)
        .args(["render", "unknown"])
        .assert()
        .code(2)
        .stderr(predicates::str::contains("not a file or entry alias"))
        .stderr(predicates::str::contains("dev"))
        .stderr(predicates::str::contains("staging"));
}

#[test]
fn render_direct_path_still_works_with_config() {
    let dir = tempfile::tempdir().unwrap();
    let root = dir.path();

    // Config exists but we use direct path
    std::fs::write(
        root.join("husako.toml"),
        r#"
[entries]
alias = "other.ts"
"#,
    )
    .unwrap();

    std::fs::write(
        root.join("entry.ts"),
        r#"
import { build } from "husako";
build([{ _render() { return { apiVersion: "v1", kind: "Namespace", metadata: { name: "test" } }; } }]);
"#,
    )
    .unwrap();

    // Direct path still works
    husako_at(root)
        .args(["render", "entry.ts"])
        .assert()
        .success()
        .stdout(predicates::str::contains("kind: Namespace"));
}

#[test]
fn render_no_config_direct_path_works() {
    let dir = tempfile::tempdir().unwrap();
    let root = dir.path();

    // No husako.toml  direct path must still work
    std::fs::write(
        root.join("entry.ts"),
        r#"
import { build } from "husako";
build([{ _render() { return { apiVersion: "v1", kind: "Namespace", metadata: { name: "test" } }; } }]);
"#,
    )
    .unwrap();

    husako_at(root)
        .args(["render", "entry.ts"])
        .assert()
        .success()
        .stdout(predicates::str::contains("kind: Namespace"));
}

#[test]
fn new_creates_husako_toml() {
    let dir = tempfile::tempdir().unwrap();
    let target = dir.path().join("my-app");

    husako()
        .args(["new", target.to_str().unwrap()])
        .assert()
        .success();

    assert!(target.join("husako.toml").exists());
    let content = std::fs::read_to_string(target.join("husako.toml")).unwrap();
    assert!(content.contains("[schemas]"));
    assert!(content.contains("source = \"release\""));
}

#[test]
fn new_project_creates_husako_toml_with_entries() {
    let dir = tempfile::tempdir().unwrap();
    let target = dir.path().join("my-app");

    husako()
        .args(["new", "--template", "project", target.to_str().unwrap()])
        .assert()
        .success();

    let content = std::fs::read_to_string(target.join("husako.toml")).unwrap();
    assert!(content.contains("[entries]"));
    assert!(content.contains("dev"));
}

#[test]
fn new_multi_env_creates_husako_toml_with_entries() {
    let dir = tempfile::tempdir().unwrap();
    let target = dir.path().join("my-app");

    husako()
        .args(["new", "--template", "multi-env", target.to_str().unwrap()])
        .assert()
        .success();

    let content = std::fs::read_to_string(target.join("husako.toml")).unwrap();
    assert!(content.contains("[entries]"));
    assert!(content.contains("dev"));
    assert!(content.contains("staging"));
    assert!(content.contains("release"));
}

#[test]
fn new_then_render_with_alias() {
    let dir = tempfile::tempdir().unwrap();
    let target = dir.path().join("my-app");

    // Scaffold project template (has [entries] dev = "env/dev.ts")
    husako()
        .args(["new", "--template", "project", target.to_str().unwrap()])
        .assert()
        .success();

    // Write k8s modules for rendering
    write_k8s_modules(&target);

    // Render using the alias "dev" instead of "env/dev.ts"
    husako_at(&target)
        .args(["render", "dev"])
        .assert()
        .success()
        .stdout(predicates::str::contains("apiVersion: apps/v1"))
        .stdout(predicates::str::contains("kind: Deployment"))
        .stdout(predicates::str::contains("name: nginx"));
}
