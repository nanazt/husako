# Plan: tsconfig.json — auto-managed artifact

## Context

The tsconfig.json is currently generated by `husako gen` and committed to VCS. The goal is to
make it a husako-managed artifact (like `.husako/types/`) — always generated fresh by the
binary, never manually edited by users. The computation lives in Rust; the file is a derived
output.

No backward compatibility required.

---

## Constraints (can't be designed away)

1. **tsserver requires a file at project root** — when editing `<root>/lib/metadata.ts`, tsserver
   searches upward: `lib/` → `<root>/`. Moving tsconfig to `.husako/tsconfig.json` breaks this
   discovery. File stays at `<root>/tsconfig.json`.

2. **tsc requires a file** — `husako check --type-check` still needs a file for tsc, but can
   generate it on-the-fly and write to `<root>/tsconfig.json`.

---

## What changes

| Aspect | Before | After |
|--------|--------|-------|
| Who writes tsconfig.json | `husako gen` only | `husako gen` + husako-lsp on open |
| Merge vs overwrite | Merges into existing | Always overwrites (canonical source) |
| VCS | Committed by users | Gitignored (auto-managed artifact) |
| `husako check --type-check` | Depends on tsconfig existing | Generates fresh before running tsc |
| File location | `<root>/tsconfig.json` | `<root>/tsconfig.json` (unchanged) |
| Path values | Same | Same |

---

## Implementation

### Step 1 — Extract `build_tsconfig_content()` from `write_tsconfig()`

**`crates/husako-core/src/lib.rs`**

Split the pure-computation from the I/O:
```rust
// New: pure in-memory builder, no I/O — pub so CLI + LSP can use it
pub fn build_tsconfig_content(
    config: Option<&HusakoConfig>,
    plugin_paths: &HashMap<String, String>,
) -> serde_json::Value {
    // builds paths object (husako, k8s/*, helm/* if charts, plugin paths)
    // returns new_tsconfig(paths)
}

// Existing: thin wrapper — now always overwrites, no merge
fn write_tsconfig(
    project_root: &Path,
    config: Option<&HusakoConfig>,
    plugin_paths: &HashMap<String, String>,
) -> Result<(), HusakoError> {
    let content = build_tsconfig_content(config, plugin_paths);
    let path = project_root.join("tsconfig.json");
    std::fs::write(path, serde_json::to_string_pretty(&content)? + "\n")
        .map_err(|e| HusakoError::GenerateIo(path.display().to_string(), e))
}
```

Remove the old merge-with-existing logic. `generate_updates_existing_tsconfig` tests go away.

Also add a lightweight plugin path scanner (avoids requiring plugin installation):
```rust
pub fn scan_installed_plugin_paths(project_root: &Path) -> HashMap<String, String> {
    // Reads .husako/plugins/<name>/plugin.toml for each installed plugin
    // Returns specifier → dts path, without re-running install
}
```

### Step 2 — `husako check --type-check` generates tsconfig before running tsc

**`crates/husako-cli/src/main.rs`** — `Commands::Check` arm

Replace the current approach (relies on tsconfig.json already existing) with:
```rust
if type_check {
    // 1. Generate tsconfig fresh in memory
    let hs_config = husako_config::load(&project_root).ok().flatten();
    let plugin_paths = husako_core::scan_installed_plugin_paths(&project_root);
    let tsconfig = husako_core::build_tsconfig_content(hs_config.as_ref(), &plugin_paths);

    // 2. Write to project root (overwrite — it's auto-managed)
    let tsconfig_path = project_root.join("tsconfig.json");
    let _ = std::fs::write(&tsconfig_path,
        serde_json::to_string_pretty(&tsconfig).unwrap_or_default() + "\n");

    // 3. Create temp entry.ts alongside entry.husako (unchanged from current fix)
    let temp_ts = /* ... as before ... */;

    // 4. Run tsc with no --project flag (discovers tsconfig.json from project root)
    let tsc_result = std::process::Command::new("tsc")
        .arg("--noEmit")
        .current_dir(&project_root)
        .output();

    // 5. Clean up only the temp .ts file; keep tsconfig.json for IDE
    if let Some(ref f) = temp_ts { let _ = std::fs::remove_file(f); }

    // 6. Handle result (unchanged)
    match tsc_result { ... }
}
```

### Step 3 — husako-lsp writes tsconfig.json on workspace load

**`crates/husako-lsp/src/workspace.rs`**

In `load()`, after `reload_chains_meta()`:
```rust
pub async fn load(&mut self, root: PathBuf) {
    self.root = Some(root.clone());
    self.reload_chains_meta(&root).await;
    self.refresh_tsconfig(&root).await;   // new
}

async fn refresh_tsconfig(&self, root: &Path) {
    let config = husako_config::load(root).ok().flatten();
    let plugin_paths = husako_core::scan_installed_plugin_paths(root);
    let content = husako_core::build_tsconfig_content(config.as_ref(), &plugin_paths);
    let path = root.join("tsconfig.json");
    if let Ok(json) = serde_json::to_string_pretty(&content) {
        let _ = tokio::fs::write(path, json + "\n").await;
    }
}
```

Effect: opening a `.husako` file in the editor refreshes `tsconfig.json` automatically,
even without running `husako gen` first.

### Step 4 — Add tsconfig.json to gitignore

**`crates/husako-sdk/src/templates/gitignore.txt`** (shared gitignore template)

Add `tsconfig.json` to the template gitignore content. This is what `husako new` and
`husako init` write as `.gitignore`.

Also update `crates/husako-core/src/lib.rs` in `scaffold()` and `init()` — both call
`write_gitignore()`. Confirm `tsconfig.json` is added there.

---

## Critical files

| File | Change |
|------|--------|
| `crates/husako-core/src/lib.rs` | Extract `build_tsconfig_content()`, add `scan_installed_plugin_paths()`, remove merge logic from `write_tsconfig()` |
| `crates/husako-cli/src/main.rs` | `check --type-check` generates tsconfig in memory before tsc |
| `crates/husako-lsp/src/workspace.rs` | `refresh_tsconfig()` on workspace load |
| `crates/husako-sdk/src/templates/gitignore.txt` | Add `tsconfig.json` |
| `crates/husako-core/src/lib.rs` | `scaffold()` / `init()` gitignore includes `tsconfig.json` |

---

## Tests to add or modify

**Delete (merge behavior removed):**
- `husako-core/src/lib.rs` line 2178: `generate_updates_existing_tsconfig()` — DELETE
- `husako-core/src/lib.rs` line 2536: `generate_updates_jsonc_tsconfig()` — DELETE
- `husako-cli/tests/integration.rs` line 884: `generate_updates_existing_tsconfig()` — DELETE

**Keep unchanged:**
- `strip_jsonc_*` tests in `lib.rs` — still valid (`strip_jsonc()` still used in `husako debug`)
- `husako-cli/tests/generate_output.rs` lines 791-828: `tsconfig_paths_point_to_generated_files()` — keep (location unchanged)

**New tests:**
- `husako-core/src/lib.rs`: `write_tsconfig_overwrites_existing()` — pre-write custom JSON to `tsconfig.json`, run `write_tsconfig()`, assert the output equals husako's canonical content exactly (old content gone)
- `husako-cli/tests/integration.rs`: `check_type_check_without_prior_gen` — `husako check --type-check` in a project that never ran `husako gen` (no tsconfig.json yet) must succeed; assert tsconfig.json is created as a side effect
- `husako-lsp/src/workspace.rs` tests: `lsp_writes_tsconfig_on_workspace_load` — `Workspace::load(root)` creates `tsconfig.json` at project root

**Confirm still passing:**
- `check_sdk_template_type_safe`

---

## Docs to modify

**User-facing docs (`.worktrees/docs-site/docs/`):**
- `docs/reference/cli.md` — `husako gen` section: note that `tsconfig.json` is auto-managed and gitignored
- `docs/guide/getting-started.md` — remove any manual tsconfig setup instructions
- `docs/guide/configuration.md` — add note that tsconfig.json is auto-generated

**Design docs (`.claude/`):**
- `CLAUDE.md` (root): Replace the JSONC gotcha ("tsconfig.json is parsed with JSONC support...") with: "tsconfig.json is a husako-managed artifact — gitignored, always overwritten by `husako gen` and husako-lsp on workspace open. Never edit it manually. `strip_jsonc()` remains in husako-core for reading tsconfig in `husako debug`."
- `.claude/architecture.md` lines 354-357, 368: Update tsconfig management description — `write_tsconfig()` now always overwrites (no merge); `build_tsconfig_content()` is the pure builder exposed as pub
- `.claude/lsp-spec.md`: Add section "Workspace initialization" — document that `workspace.load()` calls `refresh_tsconfig()` which writes `tsconfig.json` using `husako_core::build_tsconfig_content()`
- `.claude/testing.md` line 137: Update `init_project()` comment — no longer copies tsconfig.json; that is now written by `husako gen` or by the new `write_tsconfig` call under test

---

## Verification

```bash
cargo fmt --all
cargo clippy --workspace --all-targets --all-features -- -D warnings
cargo test --workspace --all-features
cargo test -p husako --test e2e_g
cargo test -p husako --test integration check_sdk_template_type_safe
cargo test -p husako --test integration check_type_check_without_prior_gen
```
