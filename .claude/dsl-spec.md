
# Builder DSL Specification

This document defines the rules for the husako builder DSL. All user-facing code, examples, templates, and generated types must follow these rules. Implementation that violates any rule listed here is a bug.

---

### 1. Authoring Style

Users write Kubernetes resources using **builder chains**. No `new` keyword, no plain object literals for resource structure. Chain starter functions come from **schema modules** — not from `"husako"`.

```typescript
import { Deployment } from "k8s/apps/v1";
import { name, namespace, label } from "k8s/meta/v1";       // ObjectMeta starters
import { name, image, imagePullPolicy } from "k8s/core/v1"; // Container starters (duplicate OK)
import husako from "husako";

const nginx = Deployment()
  .metadata(name("nginx").namespace("default").label("app", "nginx"))
  .replicas(3)
  .containers([
    name("nginx").image("nginx:1.25").imagePullPolicy("Always")
  ]);

husako.build([nginx]);
```

**Rules:**

- Every resource builder exports a PascalCase factory: `Deployment()`, `Service()`, `ConfigMap()`.
- Chain starter functions (`name()`, `namespace()`, `image()`, etc.) come from **schema modules** (`"k8s/meta/v1"`, `"k8s/core/v1"`, etc.), NOT from `"husako"`.
- `"husako"` module is **default-import only**: `import husako from "husako"`. Named imports are removed.
- `husako.build([...])` must be called exactly once per entrypoint.
- Plain objects are allowed only as leaf values where no builder/chain exists (e.g., `matchLabels`).
- `.husako` file extension: enables husako-specific behavior (duplicate import suppression, LSP).

---

### 2. Chain Starters and Context

#### Chain Starter Functions

Each OpenAPI schema generates **chain starter functions** exported from its schema module. A starter creates a `SpecFragment` that records values for that field.

```typescript
// k8s/meta/v1 exports ObjectMeta starters → return MetadataChain-compatible SpecFragment
import { name, namespace, label, annotation } from "k8s/meta/v1";

// k8s/core/v1 exports Container starters → return ContainerChain-compatible SpecFragment
import { name, image, imagePullPolicy, cpu, memory } from "k8s/core/v1";
```

#### Context Determination: Call Site Rules

**The call site determines context** — `.metadata()` expects `MetadataChain`, `.containers()` expects `ContainerChain[]`.

```typescript
.metadata(chain: MetadataChain)        // MetadataChain context
.containers(items: ContainerChain[])   // ContainerChain context
.tolerations(items: TolerationChain[]) // TolerationChain context
```

TypeScript validates at the call site — not inside the chain itself. `SpecFragment` extends both `MetadataChain` and `ContainerChain`, so it is always valid at either call site.

#### Duplicate Imports in `.husako` Files

Same-named starters from multiple schema modules can be imported simultaneously without aliasing. husako LSP suppresses TypeScript's duplicate-import error.

```typescript
// Both imports are valid — call site resolves which function applies
import { name, namespace, label } from "k8s/meta/v1";
import { name, image } from "k8s/core/v1";
```

---

### 3. Type Hierarchy (`_chains.d.ts`)

Generated by `husako gen` → `.husako/types/_chains.d.ts`.

```typescript
// MetadataChain — accepted by .metadata()
export interface MetadataChain {
  name(v: string): MetadataChain;
  namespace(v: string): MetadataChain;
  label(k: string, v: string): MetadataChain;
  annotation(k: string, v: string): MetadataChain;
  // ... all ObjectMeta fields (enum/type from OpenAPI)
}

// ContainerChain — accepted by .containers() items
export interface ContainerChain {
  name(v: string): ContainerChain;
  image(v: string): ContainerChain;
  imagePullPolicy(v: "Always" | "IfNotPresent" | "Never"): ContainerChain;
  // ... all Container fields (enum/pattern/required from OpenAPI)
}

// SpecFragment — returned by name() (both schemas); extends both chains
export interface SpecFragment extends MetadataChain, ContainerChain {
  name(v: string): SpecFragment;      // covariant override
  namespace(v: string): SpecFragment;
  image(v: string): SpecFragment;
  // ... all fields with SpecFragment return type
}

// Per-schema *Chain interfaces for ALL schema types:
export interface TolerationChain { ... }
export interface EnvVarChain { ... }
export interface ContainerPortChain { ... }
export interface VolumeMountChain { ... }
export interface ResourceRequirementsChain { ... }
// ... (all object schemas)
```

**Chain method return types:**
- `MetadataChain` methods → `MetadataChain` (same type, no narrowing)
- `ContainerChain` methods → `ContainerChain`
- `SpecFragment` methods → `SpecFragment` (covariant override)

---

### 4. Builder Hierarchy

#### _ResourceBuilder (unchanged structure, updated method signatures)

Top-level Kubernetes resources with `apiVersion` and `kind`.

| Method | Behavior |
|--------|----------|
| `metadata(chain: MetadataChain)` | Accepts SpecFragment or MetadataChain. Calls `chain._toMetadata()`. |
| `containers(items: ContainerChain[])` | Accepts SpecFragment[] or ContainerChain[]. Calls `item._toContainer()`. |
| `spec(value)` | Sets full spec. Clears `_specParts`. |
| `_setSpec(key, value)` | Sets one spec property. Clears `_spec`. |
| `_setDeep(path, value)` | Sets nested path. Clears `_spec`. |
| `set(key, value)` | Sets arbitrary top-level field. |
| `_render()` | Serializes to plain Kubernetes object. |

#### SpecFragment (replaces MetadataFragment + _SchemaBuilder-based Container)

A single internal `_createSpecFragment(init)` function creates all chain fragments at runtime. No type narrowing at runtime — TypeScript types handle validation at compile time.

Chain starters are exported from generated schema `.js` files, NOT from `husako_base.js`:
```javascript
// .husako/types/k8s/meta/v1.js:
export function name(v) { return _createSpecFragment({ _name: v }); }
// .husako/types/k8s/core/v1.js:
export function image(v) { return _createSpecFragment({ _image: v }); }
```

---

### 5. Import Rules

| Source | Exports |
|--------|---------|
| `k8s/<group>/<version>` | Resource builder factories (`Deployment`) + chain starter functions for that schema group |
| `k8s/_common` | Common type factories + common chain starters |
| `"husako"` | **Default export only**: `husako.build()` |

Named imports from `"husako"` are removed. `build`, `metadata`, `Container`, `cpu`, `memory`, `requests`, `limits`, `merge` are all removed or relocated to schema modules.

---

### 6. Copy-on-Write

Resource builders (`.metadata()`, `.replicas()`, etc.) are copy-on-write — they return a new `_ResourceBuilder` instance.

Chain fragments (`SpecFragment`) are ephemeral builder objects consumed by `_toMetadata()`/`_toContainer()`. They mutate in place (same object reference returned from each chain method), which is safe because they are not stored after being consumed.

---

### 7. Render Precedence

`_render()` builds the `spec` field using three sources, checked in order:

| Priority | Source | Set by |
|----------|--------|--------|
| 1 | `_spec` | `.spec(obj)` |
| 2 | `_specParts` | `_setSpec()`, `_setDeep()` |
| 3 | `_resources` | `.resources()` |

---

### 8. Quantity Normalization

Applied by `cpu()` and `memory()` chain starter functions.

**cpu(v):**
- `string` → pass-through (`"500m"`)
- `integer` → `String(v)` (`1` → `"1"`)
- `float` → `round(v * 1000) + "m"` (`0.5` → `"500m"`)

**memory(v):**
- `string` → pass-through (`"512Mi"`)
- `number` → `v + "Gi"` (`2` → `"2Gi"`)

---

### 9. Code Generation Heuristic

#### Resource builders (_ResourceBuilder subclass)

**Condition:** schema has `x-kubernetes-group-version-kind`.

Generated:
- Internal class extending `_ResourceBuilder`
- Per-spec-property methods (`.replicas()`, `.selector()`)
- `.metadata(meta: MetadataChain): this` — updated signature
- `.containers(items: ContainerChain[]): this` — updated signature
- PascalCase factory function (only export)

#### Chain Interface + Starter Functions

**Condition:** ANY object schema in OpenAPI.

Generated per schema:
- `*Chain` interface in `_chains.d.ts` (all fields, enum types, required annotations)
- Starter functions in the schema group `.d.ts`/`.js`

**Starter function naming:** field name as function name.
- `ObjectMeta.name` → `name()` exported from `k8s/meta/v1`
- `Container.name` → `name()` exported from `k8s/core/v1`
- `Container.image` → `image()` exported from `k8s/core/v1`

#### Deep-path shortcuts

`.containers(v)` → `_setDeep("template.spec.containers", v)` — unchanged.

---

### 10. Fragment Resolution

`_ResourceBuilder.metadata(chain)`:
- Checks `chain._husakoTag === "SpecFragment"` → calls `chain._toMetadata()`
- Otherwise throws: `metadata() requires a MetadataChain`

`_ResourceBuilder.containers(items)`:
- Maps each item: checks `item._husakoTag === "SpecFragment"` → calls `item._toContainer()`
- Otherwise throws: `containers() items must be ContainerChain`

---

### 11. husako.build() Contract

```typescript
import husako from "husako";
husako.build(input: { _render(): any } | { _render(): any }[]): void
```

**Rules:**
- Must be called **exactly once** per entrypoint. Zero calls → exit 7. Multiple calls → exit 7.
- Named import (`import { build } from "husako"`) is removed — compile error.
- Rendered output must pass strict JSON validation.

---

### 12. Validation (Dual Layer)

All format/constraint validation runs in both LSP (real-time) and `husako render` (compile-time):

| Check | LSP | husako render |
|-------|-----|---------------|
| Image format | Rule 4 (real-time warning) | `validate.rs` OCI regex → exit 7 |
| Field pattern | Rule 5 (real-time warning) | SchemaStore (already implemented) |
| Range min/max | Rule 7 (real-time warning) | SchemaStore (already implemented) |
| Quantity | Rule 2 (real-time error) | `quantity.rs` (already implemented) |
| Image existence | — | `--validate-images` flag |

---

### 13. LSP Integration

See `.claude/lsp-spec.md` for the full LSP specification.

---

### 14. Template Reuse

Resource builders are copy-on-write — any instance can be stored and reused.

```typescript
import { Deployment } from "k8s/apps/v1";
import { name, label } from "k8s/meta/v1";
import { name as cname, image } from "k8s/core/v1";
import husako from "husako";

const webDeploy = Deployment()
  .replicas(3)
  .containers([cname("web").image("nginx:1.25")]);

const prod = webDeploy.metadata(name("web-prod").label("env", "prod"));
const staging = webDeploy.metadata(name("web-staging").label("env", "staging"));

husako.build([prod, staging]);
```

---

### 15. Breaking Changes from Previous DSL

| Removed | Replacement |
|---------|-------------|
| `metadata()` factory from `"husako"` | `name()`, `namespace()` etc. from `"k8s/meta/v1"` |
| `Container()` from `"k8s/core/v1"` | `name()`, `image()` etc. from `"k8s/core/v1"` |
| `import { build } from "husako"` | `import husako from "husako"; husako.build(...)` |
| `import { cpu, memory, requests, limits, merge } from "husako"` | `import { cpu, memory } from "k8s/core/v1"`; `merge` removed |
| `MetadataFragment` type | `MetadataChain` |
| `_SchemaBuilder` for Container | `SpecFragment` / `ContainerChain` |

---
